<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=no">
<title>Space Lander</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
html,body{width:100%;height:100%;overflow:hidden;background:#000}
canvas{display:block;margin:0 auto;image-rendering:pixelated;touch-action:none;cursor:crosshair;max-width:100vw;max-height:100vh}
</style>
</head>
<body>
<canvas id="gc"></canvas>
<script>
'use strict';

/* ========================================================
   SPACE LANDER — Milestone 1: Core Flight & Terrain
   ======================================================== */

// ── Canvas Setup ──
const canvas = document.getElementById('gc');
const ctx = canvas.getContext('2d');
const W = 480, H = 720;
canvas.width = W; canvas.height = H;

function resize() {
  const ar = W / H;
  let cw = window.innerWidth, ch = window.innerHeight;
  if (cw / ch > ar) {
    canvas.style.height = ch + 'px';
    canvas.style.width = (ch * ar) + 'px';
  } else {
    canvas.style.width = cw + 'px';
    canvas.style.height = (cw / ar) + 'px';
  }
}
window.addEventListener('resize', resize);
resize();

// ── Utility Functions ──
function clamp(v, lo, hi) { return v < lo ? lo : v > hi ? hi : v; }
function lerp(a, b, t) { return a + (b - a) * t; }
function dist(x1, y1, x2, y2) { const dx = x2 - x1, dy = y2 - y1; return Math.sqrt(dx * dx + dy * dy); }
function hsl(h, s, l, a) { return a !== undefined ? `hsla(${h},${s}%,${l}%,${a})` : `hsl(${h},${s}%,${l}%)`; }
function degToRad(d) { return d * Math.PI / 180; }
function radToDeg(r) { return r * 180 / Math.PI; }

// ── Seeded PRNG (mulberry32) ──
function mulberry32(seed) {
  return function() {
    seed |= 0; seed = seed + 0x6D2B79F5 | 0;
    let t = Math.imul(seed ^ seed >>> 15, 1 | seed);
    t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  };
}

// ── Round Configuration (data-driven) ──
// requiredKills: must kill this many enemies before landing is allowed
// padAlien: if true, an alien patrols across the landing pad firing upward
const ROUNDS = [
  { round:1,  gravity:0.03, fuel:800, ammo:0,  padWidth:100,padPlacementRisk:0.0, terrainRoughness:0.08, terrainSeed:101, enemyRate:0,   enemyTypes:[],                  bombSpeed:0,   blastRadius:0,  requiredKills:0, padAlien:false },
  { round:2,  gravity:0.035,fuel:700, ammo:0,  padWidth:90, padPlacementRisk:0.25,terrainRoughness:0.15, terrainSeed:217, enemyRate:0,   enemyTypes:[],                  bombSpeed:0,   blastRadius:0,  requiredKills:0, padAlien:false },
  { round:3,  gravity:0.04, fuel:650, ammo:20, padWidth:80, padPlacementRisk:0.3, terrainRoughness:0.22, terrainSeed:318, enemyRate:0.7, enemyTypes:['turret'],          bombSpeed:2.0, blastRadius:25, requiredKills:0, padAlien:false },
  { round:4,  gravity:0.04, fuel:600, ammo:25, padWidth:74, padPlacementRisk:0.35,terrainRoughness:0.28, terrainSeed:419, enemyRate:0.8, enemyTypes:['turret','alien'],  bombSpeed:2.2, blastRadius:28, requiredKills:0, padAlien:false },
  { round:5,  gravity:0.05, fuel:560, ammo:30, padWidth:68, padPlacementRisk:0.4, terrainRoughness:0.32, terrainSeed:520, enemyRate:0.9, enemyTypes:['turret','alien'],  bombSpeed:2.4, blastRadius:30, requiredKills:0, padAlien:true  },
  { round:6,  gravity:0.05, fuel:520, ammo:35, padWidth:62, padPlacementRisk:0.45,terrainRoughness:0.36, terrainSeed:621, enemyRate:1.0, enemyTypes:['turret','alien'],  bombSpeed:2.6, blastRadius:32, requiredKills:1, padAlien:true  },
  { round:7,  gravity:0.06, fuel:500, ammo:35, padWidth:56, padPlacementRisk:0.45,terrainRoughness:0.40, terrainSeed:722, enemyRate:0.8, enemyTypes:['turret','alien'],  bombSpeed:2.6, blastRadius:35, requiredKills:1, padAlien:true  },
  { round:8,  gravity:0.06, fuel:480, ammo:35, padWidth:50, padPlacementRisk:0.45,terrainRoughness:0.44, terrainSeed:823, enemyRate:0.9, enemyTypes:['turret','alien'],  bombSpeed:2.8, blastRadius:38, requiredKills:1, padAlien:true  },
  { round:9,  gravity:0.07, fuel:460, ammo:40, padWidth:46, padPlacementRisk:0.35,terrainRoughness:0.48, terrainSeed:942, enemyRate:1.0, enemyTypes:['turret','alien'],  bombSpeed:3.0, blastRadius:40, requiredKills:2, padAlien:true  },
  { round:10, gravity:0.07, fuel:440, ammo:45, padWidth:42, padPlacementRisk:0.45,terrainRoughness:0.52, terrainSeed:1043,enemyRate:1.1, enemyTypes:['turret','alien'],  bombSpeed:3.2, blastRadius:42, requiredKills:2, padAlien:true  },
];

// ── Tips (shown on game over screen) ──
const TIPS = [
  'Hold both L+R or Up to hover in place',
  'Tap thrusters in short bursts to save fuel',
  'Kill the red pad alien before attempting to land',
  'Watch the radar to track incoming bombs',
  'Shoot enemy bombs out of the air with Space',
  'Later rounds require enemy kills before landing',
  'Press Space (or FIRE on mobile) to shoot downward',
  'Counter-thrust early to stop horizontal drift',
  'The V-SPD and H-SPD gauges turn red when unsafe',
  'You gain an extra life for each successful landing',
  'Bullets fire downward — hover above enemies to hit them',
  'Use short taps, not long holds, for precise control',
];

// ── Landing Thresholds (constant across rounds) ──
const MAX_LAND_VY = 2.2;    // max downward speed to survive (lenient)
const MAX_LAND_VX = 1.2;    // max horizontal speed (lenient)

// ── Game World Constants ──
const WORLD_TOP = 0;
const HUD_HEIGHT = 150;
const WORLD_BOTTOM = H - HUD_HEIGHT;  // terrain lives in top 570px
const TERRAIN_POINTS = 120;           // number of terrain segments
const SHIP_SIZE = 14;                 // half-size of ship

// ── Game State ──
const STATE = { TITLE: 0, PLAYING: 1, LANDED: 2, CRASHED: 3, WIN: 4, ROUND_INTRO: 5 };
let state = STATE.TITLE;
let currentRound = 0; // 0-indexed into ROUNDS
let stateTimer = 0;
let score = 0;
let roundScore = 0;
let enemiesKilled = 0;
let roundKills = 0;      // kills this round (for required-kill check)
let lives = 3;
const MAX_LIVES = 6;
let hiScore = parseInt(localStorage.getItem('spaceLanderHi') || '0', 10);

// ── Ship State ──
let ship = {};
function resetShip() {
  ship = {
    x: W / 2,
    y: 60,
    vx: 0,
    vy: 0,
    fuel: ROUNDS[currentRound].fuel,
    maxFuel: ROUNDS[currentRound].fuel,
    ammo: ROUNDS[currentRound].ammo,
    maxAmmo: ROUNDS[currentRound].ammo,
    health: 100,
    maxHealth: 100,
    thrustL: false,  // left thruster active
    thrustR: false,  // right thruster active
    armed: true,
  };
}

// ── Terrain ──
let terrainX = [];
let terrainY = [];
let padLeft = 0, padRight = 0; // x coords of landing pad edges

function generateTerrain(roundCfg) {
  const rng = mulberry32(roundCfg.terrainSeed);
  const rough = roundCfg.terrainRoughness;
  const n = TERRAIN_POINTS;
  terrainX = [];
  terrainY = [];

  // Base terrain using midpoint displacement
  const baseY = WORLD_BOTTOM - 60; // baseline near bottom of world
  const heights = new Array(n + 1);

  // Start with endpoints
  heights[0] = baseY - rng() * 80;
  heights[n] = baseY - rng() * 80;

  // Midpoint displacement
  function displace(l, r, depth) {
    if (r - l <= 1) return;
    const mid = Math.floor((l + r) / 2);
    const avg = (heights[l] + heights[r]) / 2;
    const range = (r - l) / n * 300 * rough;
    heights[mid] = avg + (rng() - 0.5) * range;
    // Clamp terrain to world
    heights[mid] = clamp(heights[mid], WORLD_BOTTOM - 350, WORLD_BOTTOM - 30);
    displace(l, mid, depth + 1);
    displace(mid, r, depth + 1);
  }
  displace(0, n, 0);

  // Fill in any undefined (shouldn't happen, but safety)
  for (let i = 0; i <= n; i++) {
    if (heights[i] === undefined) heights[i] = baseY;
  }

  // Place landing pad — choose a location based on risk
  // Lower risk = flatter, more central area; higher risk = steeper, more edge area
  const padW = roundCfg.padWidth;
  const segW = W / n;

  // Find suitable flat-ish spots and rank them by difficulty
  // After round 1, exclude center zone so player must fly sideways
  const centerZone = roundCfg.round > 1 ? 0.15 : 0; // exclude 15% around center
  const wallBuffer = 8; // keep pad away from screen edges (in segments)
  const candidates = [];
  for (let i = wallBuffer; i < n - wallBuffer; i++) {
    const slope = Math.abs(heights[i + 1] - heights[i - 1]) / (2 * segW);
    const centerDist = Math.abs(i - n / 2) / (n / 2); // 0=center, 1=edge
    // Skip center zone after round 1
    if (centerDist < centerZone) continue;
    // Skip positions too close to walls (extra safety for later rounds)
    const xPos = i * segW;
    if (xPos < padW + 15 || xPos > W - padW - 15) continue;
    const difficulty = slope * 0.6 + centerDist * 0.4;
    candidates.push({ i, difficulty });
  }
  candidates.sort((a, b) => a.difficulty - b.difficulty);

  // Pick candidate based on padPlacementRisk (0=easiest, 1=hardest)
  const pickIdx = Math.floor(roundCfg.padPlacementRisk * (candidates.length - 1) * 0.8);
  const chosen = candidates[clamp(pickIdx, 0, candidates.length - 1)];
  const padCenterI = chosen.i;

  // Flatten the pad area
  const padSegs = Math.ceil(padW / segW);
  const padStartI = clamp(padCenterI - Math.floor(padSegs / 2), 1, n - padSegs - 1);
  const padEndI = padStartI + padSegs;
  const padYVal = heights[padCenterI];

  for (let i = padStartI; i <= padEndI; i++) {
    heights[i] = padYVal;
  }

  padLeft = padStartI * segW;
  padRight = padEndI * segW;

  // Build terrain arrays
  for (let i = 0; i <= n; i++) {
    terrainX.push(i * segW);
    terrainY.push(heights[i]);
  }
}

// Get terrain height at any x via linear interpolation
function getTerrainY(x) {
  if (x <= 0) return terrainY[0];
  if (x >= W) return terrainY[terrainY.length - 1];
  const segW = W / TERRAIN_POINTS;
  const i = x / segW;
  const lo = Math.floor(i);
  const hi = Math.min(lo + 1, terrainY.length - 1);
  const t = i - lo;
  return lerp(terrainY[lo], terrainY[hi], t);
}

// ── Stars (background) ──
let stars = [];
function generateStars() {
  stars = [];
  for (let i = 0; i < 80; i++) {
    stars.push({
      x: Math.random() * W,
      y: Math.random() * WORLD_BOTTOM,
      size: Math.random() * 1.5 + 0.5,
      bright: Math.random() * 0.5 + 0.5,
    });
  }
}
generateStars();

// ── Input ──
const keys = {};
document.addEventListener('keydown', e => {
  keys[e.code] = true;
  // Prevent scrolling with arrow keys / space
  if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','Space'].includes(e.code)) {
    e.preventDefault();
  }
  handleKeyAction(e.code, true);
});
document.addEventListener('keyup', e => {
  keys[e.code] = false;
});

function handleKeyAction(code, down) {
  if (!down) return;
  initAudio();
  if (code === 'KeyM') toggleMute();
  if (state === STATE.TITLE && (code === 'Space' || code === 'Enter')) {
    startGame();
    startMusic();
  }
  if (state === STATE.ROUND_INTRO && (code === 'Space' || code === 'Enter')) {
    state = STATE.PLAYING;
  }
  if ((state === STATE.LANDED) && (code === 'Space' || code === 'Enter')) {
    nextRound();
  }
  if ((state === STATE.CRASHED) && (code === 'Space' || code === 'Enter')) {
    restartRound();
  }
  if (state === STATE.WIN && (code === 'Space' || code === 'Enter')) {
    state = STATE.TITLE;
  }
  // Fire
  if (state === STATE.PLAYING && code === 'Space') {
    fireBullet();
  }
}

// ── Touch Controls ──
let touchThrust = false, touchLeft = false, touchRight = false;
let touchFire = false;
let isMobile = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);

// Touch zones: left half = left booster, right half = right booster, bottom panel = fire
const PANEL_ZONE = WORLD_BOTTOM / H; // ~0.792 — everything below this is the HUD/fire zone

canvas.addEventListener('touchstart', e => { e.preventDefault(); handleTouchEvent(e); }, { passive: false });
canvas.addEventListener('touchmove', e => { e.preventDefault(); handleTouchEvent(e); }, { passive: false });
canvas.addEventListener('touchend', e => { e.preventDefault(); handleTouchEvent(e); }, { passive: false });
canvas.addEventListener('touchcancel', e => {
  e.preventDefault();
  touchThrust = false; touchLeft = false; touchRight = false; touchFire = false;
}, { passive: false });

function handleTouchEvent(e) {
  isMobile = true;
  initAudio();

  // Reset all touch states, then check active touches
  touchThrust = false; touchLeft = false; touchRight = false; touchFire = false;
  const r = canvas.getBoundingClientRect();

  for (let i = 0; i < e.touches.length; i++) {
    const tx = (e.touches[i].clientX - r.left) / r.width;
    const ty = (e.touches[i].clientY - r.top) / r.height;

    if (ty >= PANEL_ZONE) {
      // Bottom panel = fire
      touchFire = true;
    } else if (tx < 0.5) {
      // Left half of game area = left booster
      touchLeft = true;
    } else {
      // Right half of game area = right booster
      touchRight = true;
    }
  }

  // Tap to advance state
  if (e.type === 'touchstart') {
    if (state === STATE.TITLE) { startGame(); startMusic(); return; }
    if (state === STATE.ROUND_INTRO) { state = STATE.PLAYING; return; }
    if (state === STATE.LANDED) { nextRound(); return; }
    if (state === STATE.CRASHED) { restartRound(); return; }
    if (state === STATE.WIN) { state = STATE.TITLE; return; }
  }
}

// ── Screen Shake ──
let shakeX = 0, shakeY = 0, shakeMag = 0;

function triggerShake(mag) {
  shakeMag = Math.max(shakeMag, mag);
}

function updateShake(dt) {
  if (shakeMag > 0) {
    shakeMag = Math.max(0, shakeMag - dt * 30);
    shakeX = (Math.random() - 0.5) * shakeMag;
    shakeY = (Math.random() - 0.5) * shakeMag;
  } else {
    shakeX = 0; shakeY = 0;
  }
}

// ── Particles (simple pool) ──
const MAX_PARTICLES = 300;
const particles = [];
for (let i = 0; i < MAX_PARTICLES; i++) {
  particles.push({ active: false, x:0, y:0, vx:0, vy:0, life:0, maxLife:0, r:0, color:'', type:0 });
}

function spawnParticle(x, y, vx, vy, life, r, color, type) {
  for (let i = 0; i < MAX_PARTICLES; i++) {
    if (!particles[i].active) {
      const p = particles[i];
      p.active = true; p.x = x; p.y = y; p.vx = vx; p.vy = vy;
      p.life = life; p.maxLife = life; p.r = r; p.color = color; p.type = type || 0;
      return p;
    }
  }
  return null;
}

function updateParticles(dt) {
  for (let i = 0; i < MAX_PARTICLES; i++) {
    const p = particles[i];
    if (!p.active) continue;
    p.x += p.vx * dt * 60;
    p.y += p.vy * dt * 60;
    p.life -= dt;
    if (p.life <= 0) p.active = false;
  }
}

function drawParticles() {
  for (let i = 0; i < MAX_PARTICLES; i++) {
    const p = particles[i];
    if (!p.active) continue;
    const alpha = clamp(p.life / p.maxLife, 0, 1);
    ctx.globalAlpha = alpha;
    ctx.fillStyle = p.color;
    ctx.fillRect(p.x - p.r, p.y - p.r, p.r * 2, p.r * 2);
  }
  ctx.globalAlpha = 1;
}

function clearParticles() {
  for (let i = 0; i < MAX_PARTICLES; i++) particles[i].active = false;
}

// ── Bullets (Player Projectiles) ──
const MAX_BULLETS = 30;
const bullets = [];
for (let i = 0; i < MAX_BULLETS; i++) {
  bullets.push({ active: false, x:0, y:0, vx:0, vy:0, life:0 });
}
const BULLET_SPEED = 6;
const BULLET_LIFE = 1.5; // seconds
let fireTimer = 0;
const FIRE_RATE = 0.12; // seconds between shots

function fireBullet() {
  if (ship.ammo <= 0) return;
  if (fireTimer > 0) return;
  fireTimer = FIRE_RATE;
  ship.ammo--;
  sfxFire();

  for (let i = 0; i < MAX_BULLETS; i++) {
    if (!bullets[i].active) {
      const b = bullets[i];
      b.active = true;
      // Fire downward from belly of ship
      b.x = ship.x;
      b.y = ship.y + SHIP_SIZE;
      // Slight aim based on active thrusters (moving left = bullets angle slightly left)
      const aimX = ship.vx * 0.15;
      b.vx = aimX;
      b.vy = BULLET_SPEED;
      b.life = BULLET_LIFE;
      return;
    }
  }
}

function updateBullets(dt) {
  fireTimer = Math.max(0, fireTimer - dt);

  for (let i = 0; i < MAX_BULLETS; i++) {
    const b = bullets[i];
    if (!b.active) continue;
    b.x += b.vx * dt * 60;
    b.y += b.vy * dt * 60;
    b.life -= dt;

    // Off-screen or expired
    if (b.life <= 0 || b.x < -10 || b.x > W + 10 || b.y < -10 || b.y > H + 10) {
      b.active = false;
      continue;
    }

    // Terrain collision
    if (b.y >= getTerrainY(b.x)) {
      b.active = false;
      // Spark particles
      for (let j = 0; j < 4; j++) {
        spawnParticle(b.x, b.y,
          (Math.random() - 0.5) * 2, -Math.random() * 2,
          0.15, 1, '#ffcc44', 0);
      }
      continue;
    }

    // Enemy collision
    let bulletHit = false;
    for (let j = 0; j < MAX_ENEMIES; j++) {
      const e = enemies[j];
      if (!e.active || e.state !== 'active') continue;
      const hitDist = e.type === 'turret' ? 12 : 12;
      if (dist(b.x, b.y, e.x, e.y - 5) < hitDist) {
        e.hp--;
        if (e.hp <= 0) {
          e.state = 'dying';
          e.stateTimer = 0;
          spawnExplosion(e.x, e.y);
          enemiesKilled++;
          roundKills++;
          score += e.type === 'turret' ? 100 : e.type === 'padAlien' ? 300 : 200;
          sfxEnemyDie();
        } else {
          sfxEnemyHit();
        }
        bulletHit = true;
        break;
      }
    }
    if (bulletHit) { b.active = false; continue; }

    // Bomb collision (shoot down bombs)
    for (let j = 0; j < MAX_BOMBS; j++) {
      const bm = bombs[j];
      if (!bm.active) continue;
      if (dist(b.x, b.y, bm.x, bm.y) < 8) {
        bm.active = false;
        b.active = false;
        // Small pop
        for (let k = 0; k < 6; k++) {
          spawnParticle(bm.x, bm.y,
            (Math.random()-0.5)*2, (Math.random()-0.5)*2,
            0.2, 1.5, '#ffaa00', 0);
        }
        bulletHit = true;
        break;
      }
    }
    if (bulletHit) continue;
  }
}

function drawBullets() {
  ctx.fillStyle = '#ffff44';
  for (let i = 0; i < MAX_BULLETS; i++) {
    const b = bullets[i];
    if (!b.active) continue;
    ctx.fillRect(b.x - 1.5, b.y - 1.5, 3, 3);
    // Trail
    ctx.globalAlpha = 0.4;
    ctx.fillRect(b.x - b.vx * 0.1 - 1, b.y - b.vy * 0.1 - 1, 2, 2);
    ctx.globalAlpha = 1;
  }
}

function clearBullets() {
  for (let i = 0; i < MAX_BULLETS; i++) bullets[i].active = false;
}

// ── Enemies ──
const MAX_ENEMIES = 12;
const enemies = [];
for (let i = 0; i < MAX_ENEMIES; i++) {
  enemies.push({
    active: false,
    type: 'turret', // 'turret' or 'alien'
    x: 0, y: 0,
    vx: 0, vy: 0,
    hp: 1, maxHp: 1,
    state: 'telegraph', // 'telegraph', 'active', 'dying'
    stateTimer: 0,
    fireTimer: 0,
    patrolDir: 1,
    patrolRange: 60,
    originX: 0,
  });
}

let enemySpawnTimer = 0;
let enemiesSpawned = 0;

// ── Bombs (Enemy Projectiles) ──
const MAX_BOMBS = 20;
const bombs = [];
for (let i = 0; i < MAX_BOMBS; i++) {
  bombs.push({ active: false, x:0, y:0, vx:0, vy:0, life:0 });
}

function spawnEnemy(type) {
  for (let i = 0; i < MAX_ENEMIES; i++) {
    if (!enemies[i].active) {
      const e = enemies[i];
      e.active = true;
      e.type = type;
      e.state = 'telegraph';
      e.stateTimer = 0;
      sfxTelegraph();

      if (type === 'turret') {
        // Place on terrain, avoiding the landing pad
        let ex;
        do {
          ex = 30 + Math.random() * (W - 60);
        } while (ex > padLeft - 30 && ex < padRight + 30);
        e.x = ex;
        e.y = getTerrainY(ex);
        e.vx = 0; e.vy = 0;
        e.hp = 1 + Math.floor(Math.random() * 2); // 1-2 HP
        e.maxHp = e.hp;
        e.fireTimer = 1.5 + Math.random() * 2;
      } else { // alien
        e.x = Math.random() < 0.5 ? -10 : W + 10;
        e.y = 60 + Math.random() * (WORLD_BOTTOM * 0.4);
        e.vx = e.x < 0 ? 0.8 : -0.8;
        e.vy = 0;
        e.hp = 2 + Math.floor(Math.random() * 2); // 2-3 HP
        e.maxHp = e.hp;
        e.fireTimer = 2 + Math.random() * 2;
        e.patrolDir = e.vx > 0 ? 1 : -1;
        e.originX = e.x;
        e.patrolRange = 80 + Math.random() * 60;
      }
      return;
    }
  }
}

function spawnPadAlien() {
  for (let i = 0; i < MAX_ENEMIES; i++) {
    if (!enemies[i].active) {
      const e = enemies[i];
      e.active = true;
      e.type = 'padAlien';
      e.state = 'telegraph';
      e.stateTimer = 0;
      sfxTelegraph();
      // Start at one end of the pad
      const padMid = (padLeft + padRight) / 2;
      const padY = getTerrainY(padMid);
      e.x = padLeft;
      e.y = padY - 10; // just above pad surface
      e.vx = 0.5;
      e.vy = 0;
      e.hp = 2;
      e.maxHp = 2;
      e.fireTimer = 1.5;
      e.originX = padMid;
      e.patrolRange = (padRight - padLeft) / 2;
      e.patrolDir = 1;
      return;
    }
  }
}

function fireBombDir(ex, ey, vx, vy) {
  sfxBombShot();
  for (let i = 0; i < MAX_BOMBS; i++) {
    if (!bombs[i].active) {
      const b = bombs[i];
      b.active = true;
      b.x = ex; b.y = ey;
      b.vx = vx; b.vy = vy;
      b.life = 3;
      return;
    }
  }
}

function fireBomb(ex, ey) {
  sfxBombShot();
  const cfg = ROUNDS[currentRound];
  for (let i = 0; i < MAX_BOMBS; i++) {
    if (!bombs[i].active) {
      const b = bombs[i];
      b.active = true;
      b.x = ex; b.y = ey;
      // Aim at player — lead the target slightly
      const dx = ship.x + ship.vx * 15 - ex;
      const dy = ship.y + ship.vy * 10 - ey;
      const d = Math.sqrt(dx * dx + dy * dy) || 1;
      const speed = Math.max(cfg.bombSpeed, 1.8); // minimum speed so bombs fly far
      b.vx = (dx / d) * speed + (Math.random() - 0.5) * 0.4;
      b.vy = (dy / d) * speed + (Math.random() - 0.5) * 0.4;
      b.life = 5;
      return;
    }
  }
}

function updateEnemies(dt) {
  const cfg = ROUNDS[currentRound];

  // Spawn timer
  if (cfg.enemyRate > 0) {
    enemySpawnTimer -= dt;
    if (enemySpawnTimer <= 0) {
      // Pick a random enemy type from available types
      const types = cfg.enemyTypes;
      if (types.length > 0) {
        const type = types[Math.floor(Math.random() * types.length)];
        spawnEnemy(type);
        enemiesSpawned++;
      }
      // Next spawn interval (inversely proportional to rate)
      enemySpawnTimer = (3 + Math.random() * 3) / cfg.enemyRate;
    }
  }

  for (let i = 0; i < MAX_ENEMIES; i++) {
    const e = enemies[i];
    if (!e.active) continue;

    e.stateTimer += dt;

    if (e.state === 'telegraph') {
      // Green head visible for 1 second, then activate
      if (e.stateTimer >= 1.0) {
        e.state = 'active';
        e.stateTimer = 0;
        if (e.type === 'alien') {
          e.originX = e.x; // reset patrol origin once active
        }
      }
      continue; // Don't move or shoot while telegraphing
    }

    if (e.state === 'dying') {
      if (e.stateTimer >= 0.3) {
        e.active = false;
      }
      continue;
    }

    // Active behavior
    if (e.type === 'turret') {
      // Stationary, just fire
      e.fireTimer -= dt;
      if (e.fireTimer <= 0) {
        fireBomb(e.x, e.y - 8);
        e.fireTimer = 2 + Math.random() * 1.5;
      }
    } else if (e.type === 'padAlien') {
      // Patrol across the landing pad, fire upward
      e.x += e.vx * dt * 60;
      // Bounce within pad bounds
      if (e.x <= padLeft + 5 || e.x >= padRight - 5) {
        e.vx *= -1;
        e.patrolDir *= -1;
      }
      e.fireTimer -= dt;
      if (e.fireTimer <= 0) {
        // Fire straight up along landing path
        fireBombDir(e.x, e.y - 6, 0, -ROUNDS[currentRound].bombSpeed);
        e.fireTimer = 1.2 + Math.random() * 1;
      }
    } else { // alien
      // Patrol back and forth
      e.x += e.vx * dt * 60;
      e.y += Math.sin(e.stateTimer * 1.5) * 0.3; // gentle bob

      // Reverse at patrol bounds
      if (Math.abs(e.x - e.originX) > e.patrolRange) {
        e.vx *= -1;
        e.patrolDir *= -1;
      }
      // Keep on screen
      if (e.x < 10) { e.x = 10; e.vx = Math.abs(e.vx); }
      if (e.x > W - 10) { e.x = W - 10; e.vx = -Math.abs(e.vx); }

      e.fireTimer -= dt;
      if (e.fireTimer <= 0) {
        fireBomb(e.x, e.y + 6);
        e.fireTimer = 1.5 + Math.random() * 2;
      }
    }
  }
}

function updateBombs(dt) {
  const cfg = ROUNDS[currentRound];

  for (let i = 0; i < MAX_BOMBS; i++) {
    const b = bombs[i];
    if (!b.active) continue;
    b.x += b.vx * dt * 60;
    b.y += b.vy * dt * 60;
    b.vy += 0.02 * dt * 60; // slight gravity on bombs
    b.life -= dt;

    if (b.life <= 0 || b.x < -20 || b.x > W + 20 || b.y < -20) {
      b.active = false;
      continue;
    }

    // Terrain collision → explode
    if (b.y >= getTerrainY(b.x)) {
      explodeBomb(b.x, b.y, cfg.blastRadius);
      b.active = false;
      continue;
    }

    // Hit player? Check distance
    const dToShip = dist(b.x, b.y, ship.x, ship.y);
    if (dToShip < SHIP_SIZE + 4) {
      explodeBomb(b.x, b.y, cfg.blastRadius);
      b.active = false;
      continue;
    }
  }
}

function explodeBomb(x, y, radius) {
  sfxBombExplode();
  triggerShake(4);
  // Hit by bomb = instant death
  const dToShip = dist(x, y, ship.x, ship.y);
  if (dToShip < radius && state === STATE.PLAYING) {
    crashShip();
  }

  // Visual explosion
  for (let i = 0; i < 20; i++) {
    const ang = Math.random() * Math.PI * 2;
    const spd = 0.5 + Math.random() * 2;
    spawnParticle(x, y,
      Math.cos(ang) * spd, Math.sin(ang) * spd,
      0.3 + Math.random() * 0.4,
      1.5 + Math.random() * 2,
      ['#ff6600', '#ff3300', '#ffaa00'][Math.floor(Math.random() * 3)],
      0);
  }

  // Blast radius ring (brief)
  spawnParticle(x, y, 0, 0, 0.15, radius * 0.3, 'rgba(255,100,0,0.3)', 1);
}

function drawEnemies() {
  for (let i = 0; i < MAX_ENEMIES; i++) {
    const e = enemies[i];
    if (!e.active) continue;

    if (e.state === 'telegraph') {
      // Green head peeking up
      const bob = Math.sin(e.stateTimer * 12) * 2;
      const rise = Math.min(e.stateTimer / 0.5, 1) * 8;
      ctx.fillStyle = '#44ff44';
      ctx.beginPath();
      ctx.arc(e.x, e.y - rise + bob, 5, 0, Math.PI * 2);
      ctx.fill();
      // Eyes
      ctx.fillStyle = '#000';
      ctx.fillRect(e.x - 2, e.y - rise + bob - 1, 1.5, 1.5);
      ctx.fillRect(e.x + 1, e.y - rise + bob - 1, 1.5, 1.5);
      continue;
    }

    if (e.state === 'dying') {
      ctx.globalAlpha = 1 - e.stateTimer / 0.3;
      ctx.fillStyle = '#ff4400';
      ctx.fillRect(e.x - 6, e.y - 6, 12, 12);
      ctx.globalAlpha = 1;
      continue;
    }

    // Active enemies
    if (e.type === 'turret') {
      // Base
      ctx.fillStyle = '#884444';
      ctx.fillRect(e.x - 8, e.y - 10, 16, 10);
      // Barrel - aim at player
      const aimAng = Math.atan2(ship.x - e.x, -(ship.y - e.y));
      ctx.save();
      ctx.translate(e.x, e.y - 10);
      ctx.rotate(aimAng);
      ctx.fillStyle = '#aa6666';
      ctx.fillRect(-2, -10, 4, 10);
      ctx.restore();
      // HP pips
      drawEnemyHP(e);
    } else if (e.type === 'padAlien') {
      // Pad alien — crawls across the pad, distinct red/orange color
      ctx.fillStyle = '#cc4422';
      ctx.beginPath();
      ctx.ellipse(e.x, e.y, 8, 6, 0, 0, Math.PI * 2);
      ctx.fill();
      // Antennae
      ctx.strokeStyle = '#ff6644';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(e.x - 3, e.y - 5);
      ctx.lineTo(e.x - 5, e.y - 10);
      ctx.moveTo(e.x + 3, e.y - 5);
      ctx.lineTo(e.x + 5, e.y - 10);
      ctx.stroke();
      // Eyes
      ctx.fillStyle = '#ff0';
      ctx.fillRect(e.x - 3, e.y - 2, 2, 2);
      ctx.fillRect(e.x + 1, e.y - 2, 2, 2);
      drawEnemyHP(e);
    } else { // alien
      // Body
      ctx.fillStyle = '#66aa44';
      ctx.beginPath();
      ctx.ellipse(e.x, e.y, 10, 7, 0, 0, Math.PI * 2);
      ctx.fill();
      // Dome
      ctx.fillStyle = '#88cc66';
      ctx.beginPath();
      ctx.ellipse(e.x, e.y - 5, 6, 5, 0, Math.PI, 0);
      ctx.fill();
      // Eyes
      ctx.fillStyle = '#ff0';
      ctx.fillRect(e.x - 3, e.y - 2, 2, 2);
      ctx.fillRect(e.x + 1, e.y - 2, 2, 2);
      // HP pips
      drawEnemyHP(e);
    }
  }
}

function drawEnemyHP(e) {
  if (e.hp >= e.maxHp) return;
  const barW = 14;
  const barH = 2;
  const bx = e.x - barW / 2;
  const by = e.type === 'turret' ? e.y - 16 : e.y - 14;
  ctx.fillStyle = '#400';
  ctx.fillRect(bx, by, barW, barH);
  ctx.fillStyle = '#f44';
  ctx.fillRect(bx, by, barW * (e.hp / e.maxHp), barH);
}

function drawBombs() {
  for (let i = 0; i < MAX_BOMBS; i++) {
    const b = bombs[i];
    if (!b.active) continue;
    // Bomb body
    ctx.fillStyle = '#ff4400';
    ctx.beginPath();
    ctx.arc(b.x, b.y, 3, 0, Math.PI * 2);
    ctx.fill();
    // Glow
    ctx.globalAlpha = 0.3;
    ctx.fillStyle = '#ff8800';
    ctx.beginPath();
    ctx.arc(b.x, b.y, 5, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;
    // Trail
    ctx.fillStyle = '#ff6600';
    ctx.globalAlpha = 0.4;
    ctx.fillRect(b.x - b.vx * 0.15 - 1, b.y - b.vy * 0.15 - 1, 2, 2);
    ctx.globalAlpha = 1;
  }
}

function clearEnemies() {
  for (let i = 0; i < MAX_ENEMIES; i++) enemies[i].active = false;
  for (let i = 0; i < MAX_BOMBS; i++) bombs[i].active = false;
  enemySpawnTimer = 3; // delay before first enemy
  enemiesSpawned = 0;
}

// ── Game Flow ──
function startGame() {
  currentRound = 0;
  score = 0;
  enemiesKilled = 0;
  lives = 3;
  startRound();
}

function startRound() {
  const cfg = ROUNDS[currentRound];
  terrainX = []; terrainY = [];
  generateTerrain(cfg);
  resetShip();
  clearParticles();
  clearBullets();
  clearEnemies();
  roundKills = 0;
  // Spawn pad alien if configured
  if (cfg.padAlien) {
    spawnPadAlien();
  }
  state = STATE.ROUND_INTRO;
  stateTimer = 0;
}

function nextRound() {
  currentRound++;
  if (currentRound >= ROUNDS.length) {
    state = STATE.WIN;
    stateTimer = 0;
    stopMusic();
    if (score > hiScore) {
      hiScore = score;
      localStorage.setItem('spaceLanderHi', String(hiScore));
    }
  } else {
    startRound();
  }
}

function crashShip() {
  spawnExplosion(ship.x, ship.y);
  lives--;
  if (lives <= 0) {
    state = STATE.CRASHED;  // game over
    stateTimer = 0;
    sfxCrash();
    stopMusic();
    if (score > hiScore) {
      hiScore = score;
      localStorage.setItem('spaceLanderHi', String(hiScore));
    }
  } else {
    state = STATE.CRASHED;
    stateTimer = 0;
    sfxCrash();
  }
}

function restartRound() {
  if (lives <= 0) {
    // Game over — back to title
    state = STATE.TITLE;
    return;
  }
  startRound();
}

// ── Physics Update ──
function updatePlaying(dt) {
  const cfg = ROUNDS[currentRound];

  // ── Side Thrusters ──
  // Left thruster: fires down-left at 45°, pushes ship up-right
  // Right thruster: fires down-right at 45°, pushes ship up-left
  // Both together: horizontal cancels, net upward thrust
  const thrustPower = 0.09;
  const THRUSTER_ANGLE = Math.PI / 4; // 45 degrees
  const leftOn = (keys['ArrowLeft'] || touchLeft) && ship.fuel > 0;
  const rightOn = (keys['ArrowRight'] || touchRight) && ship.fuel > 0;
  const upOn = (keys['ArrowUp'] || touchThrust) && ship.fuel > 0;

  ship.thrustL = leftOn || upOn;
  ship.thrustR = rightOn || upOn;

  if (ship.thrustL) {
    // Left thruster pushes up and to the right
    ship.vx += Math.sin(THRUSTER_ANGLE) * thrustPower * dt * 60;   // rightward
    ship.vy += -Math.cos(THRUSTER_ANGLE) * thrustPower * dt * 60;  // upward
    ship.fuel -= dt * 60 * 0.5;
    spawnThrusterParticle(-1); // left nozzle
  }
  if (ship.thrustR) {
    // Right thruster pushes up and to the left
    ship.vx += -Math.sin(THRUSTER_ANGLE) * thrustPower * dt * 60;  // leftward
    ship.vy += -Math.cos(THRUSTER_ANGLE) * thrustPower * dt * 60;  // upward
    ship.fuel -= dt * 60 * 0.5;
    spawnThrusterParticle(1);  // right nozzle
  }

  // Thrust SFX (throttled)
  if (ship.thrustL || ship.thrustR) {
    if (Date.now() - lastThrustSfx > 80) { sfxThrust(); lastThrustSfx = Date.now(); }
  }
  ship.fuel = Math.max(0, ship.fuel);

  // Gravity
  ship.vy += cfg.gravity * dt * 60;

  // Horizontal drag — gentle dampening to reduce drift
  ship.vx *= 0.997;

  // Apply velocity
  ship.x += ship.vx * dt * 60;
  ship.y += ship.vy * dt * 60;

  // Wall collision (no wrapping — hit the edge = crash)
  if (ship.x - SHIP_SIZE < 2 || ship.x + SHIP_SIZE > W - 2) {
    crashShip();
    return;
  }

  // Clamp top
  if (ship.y < 10) { ship.y = 10; ship.vy = Math.max(0, ship.vy); }

  // ── Collision Detection ──
  const shipBottom = ship.y + SHIP_SIZE;
  const terrainAtShip = getTerrainY(ship.x);

  if (shipBottom >= terrainAtShip) {
    // Check if on landing pad
    const onPad = ship.x >= padLeft && ship.x <= padRight;
    const landingOk = Math.abs(ship.vy) <= MAX_LAND_VY &&
                      Math.abs(ship.vx) <= MAX_LAND_VX;
    // Check required kills
    const killsOk = roundKills >= cfg.requiredKills;
    // Check no pad alien blocking
    let padBlocked = false;
    for (let i = 0; i < MAX_ENEMIES; i++) {
      const e = enemies[i];
      if (e.active && e.type === 'padAlien' && e.state === 'active') {
        padBlocked = true;
        break;
      }
    }

    if (onPad && landingOk && killsOk && !padBlocked) {
      // Successful landing
      ship.y = terrainAtShip - SHIP_SIZE;
      ship.vx = 0; ship.vy = 0;
      // Score: fuel bonus + lives bonus + round multiplier
      roundScore = Math.floor(ship.fuel) * 2 + lives * 50 + (currentRound + 1) * 50;
      score += roundScore;
      // Gain a life
      lives = Math.min(lives + 1, MAX_LIVES);
      state = STATE.LANDED;
      stateTimer = 0;
      sfxLanding();
    } else if (onPad && landingOk && (!killsOk || padBlocked)) {
      // Bounced off — can't land yet, push back up gently
      ship.y = terrainAtShip - SHIP_SIZE - 2;
      ship.vy = -1;
    } else {
      // Crash!
      crashShip();
    }
  }

  // Held fire (Space key or touch fire button)
  if (keys['Space'] || touchFire) {
    fireBullet();
  }

  updateBullets(dt);
  updateEnemies(dt);
  updateBombs(dt);
  updateParticles(dt);
}

function spawnThrusterParticle(side) {
  // side: -1 = left nozzle, 1 = right nozzle
  if (Math.random() > 0.6) return;
  // Nozzle positions at bottom corners of the ship
  const nozzleX = ship.x + side * SHIP_SIZE * 0.7;
  const nozzleY = ship.y + SHIP_SIZE * 0.7;
  // Exhaust fires at 45° outward-downward
  const exVx = side * (1.5 + Math.random()) + (Math.random() - 0.5) * 0.4;
  const exVy = (1.5 + Math.random()) + (Math.random() - 0.5) * 0.4;
  spawnParticle(
    nozzleX + (Math.random() - 0.5) * 3,
    nozzleY + (Math.random() - 0.5) * 2,
    exVx, exVy,
    0.25 + Math.random() * 0.2,
    1.5 + Math.random() * 1.5,
    Math.random() < 0.5 ? '#ff6622' : '#ffaa22',
    0
  );
}

function spawnExplosion(x, y) {
  triggerShake(8);
  for (let i = 0; i < 40; i++) {
    const ang = Math.random() * Math.PI * 2;
    const spd = 1 + Math.random() * 3;
    spawnParticle(
      x + (Math.random() - 0.5) * 10,
      y + (Math.random() - 0.5) * 10,
      Math.cos(ang) * spd,
      Math.sin(ang) * spd,
      0.5 + Math.random() * 0.8,
      1.5 + Math.random() * 2,
      ['#ff4400', '#ff8800', '#ffcc00', '#ffffff'][Math.floor(Math.random() * 4)],
      0
    );
  }
}

// ── Drawing ──
function drawStars() {
  for (let i = 0; i < stars.length; i++) {
    const s = stars[i];
    ctx.globalAlpha = s.bright * (0.7 + Math.sin(Date.now() * 0.001 + i) * 0.3);
    ctx.fillStyle = '#fff';
    ctx.fillRect(s.x - s.size / 2, s.y - s.size / 2, s.size, s.size);
  }
  ctx.globalAlpha = 1;
}

function drawTerrain() {
  // Wall borders (thin lines on left and right edges)
  ctx.strokeStyle = '#ff4444';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(1, 0); ctx.lineTo(1, WORLD_BOTTOM);
  ctx.moveTo(W - 1, 0); ctx.lineTo(W - 1, WORLD_BOTTOM);
  ctx.stroke();
  // Subtle glow
  ctx.strokeStyle = 'rgba(255,68,68,0.2)';
  ctx.lineWidth = 4;
  ctx.beginPath();
  ctx.moveTo(2, 0); ctx.lineTo(2, WORLD_BOTTOM);
  ctx.moveTo(W - 2, 0); ctx.lineTo(W - 2, WORLD_BOTTOM);
  ctx.stroke();

  // Fill terrain
  ctx.beginPath();
  ctx.moveTo(0, H);
  for (let i = 0; i < terrainX.length; i++) {
    ctx.lineTo(terrainX[i], terrainY[i]);
  }
  ctx.lineTo(W, H);
  ctx.closePath();

  // Gradient fill
  const grad = ctx.createLinearGradient(0, WORLD_BOTTOM - 200, 0, WORLD_BOTTOM);
  grad.addColorStop(0, '#553322');
  grad.addColorStop(0.5, '#443322');
  grad.addColorStop(1, '#332211');
  ctx.fillStyle = grad;
  ctx.fill();

  // Terrain outline
  ctx.beginPath();
  for (let i = 0; i < terrainX.length; i++) {
    if (i === 0) ctx.moveTo(terrainX[i], terrainY[i]);
    else ctx.lineTo(terrainX[i], terrainY[i]);
  }
  ctx.strokeStyle = '#886644';
  ctx.lineWidth = 2;
  ctx.stroke();

  // Landing pad
  ctx.fillStyle = '#00ff88';
  const padY = getTerrainY((padLeft + padRight) / 2);
  ctx.fillRect(padLeft, padY - 3, padRight - padLeft, 6);

  // Pad markers
  ctx.strokeStyle = '#00ff88';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(padLeft, padY - 12); ctx.lineTo(padLeft, padY);
  ctx.moveTo(padRight, padY - 12); ctx.lineTo(padRight, padY);
  ctx.stroke();

  // Pad light blink
  const blink = Math.sin(Date.now() * 0.005) > 0;
  if (blink) {
    ctx.fillStyle = '#00ff88';
    ctx.beginPath();
    ctx.arc(padLeft + 3, padY - 10, 2, 0, Math.PI * 2);
    ctx.arc(padRight - 3, padY - 10, 2, 0, Math.PI * 2);
    ctx.fill();
  }
}

function drawShip() {
  if (state === STATE.CRASHED) return;
  const S = SHIP_SIZE;

  ctx.save();
  ctx.translate(ship.x, ship.y);
  // No rotation — ship always upright

  // ── Landing legs (wide stance) ──
  ctx.strokeStyle = '#8899aa';
  ctx.lineWidth = 2;
  // Left leg
  ctx.beginPath();
  ctx.moveTo(-S * 0.5, S * 0.6);
  ctx.lineTo(-S * 1.1, S + 6);
  ctx.stroke();
  // Right leg
  ctx.beginPath();
  ctx.moveTo(S * 0.5, S * 0.6);
  ctx.lineTo(S * 1.1, S + 6);
  ctx.stroke();
  // Feet (wide pads)
  ctx.strokeStyle = '#aabbcc';
  ctx.lineWidth = 2.5;
  ctx.beginPath();
  ctx.moveTo(-S * 1.3, S + 6);
  ctx.lineTo(-S * 0.85, S + 6);
  ctx.moveTo(S * 0.85, S + 6);
  ctx.lineTo(S * 1.3, S + 6);
  ctx.stroke();

  // ── Main body (wide boxy lander) ──
  ctx.fillStyle = '#c0ccdd';
  ctx.strokeStyle = '#778899';
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.moveTo(-S * 0.9, S * 0.6);   // bottom-left
  ctx.lineTo(-S * 0.7, -S * 0.3);  // upper-left
  ctx.lineTo(-S * 0.3, -S * 0.6);  // top-left shoulder
  ctx.lineTo(S * 0.3, -S * 0.6);   // top-right shoulder
  ctx.lineTo(S * 0.7, -S * 0.3);   // upper-right
  ctx.lineTo(S * 0.9, S * 0.6);    // bottom-right
  ctx.closePath();
  ctx.fill();
  ctx.stroke();

  // ── Dome / cockpit window ──
  ctx.fillStyle = '#44aaff';
  ctx.strokeStyle = '#3388cc';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.arc(0, -S * 0.55, S * 0.35, Math.PI, 0);
  ctx.closePath();
  ctx.fill();
  ctx.stroke();

  // ── Side thruster nozzles ──
  // Left nozzle (angled outward)
  ctx.fillStyle = ship.thrustL ? '#ffaa44' : '#667788';
  ctx.strokeStyle = '#556677';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(-S * 0.75, S * 0.3);
  ctx.lineTo(-S * 1.05, S * 0.7);
  ctx.lineTo(-S * 0.8, S * 0.7);
  ctx.closePath();
  ctx.fill();
  ctx.stroke();

  // Right nozzle (angled outward)
  ctx.fillStyle = ship.thrustR ? '#ffaa44' : '#667788';
  ctx.beginPath();
  ctx.moveTo(S * 0.75, S * 0.3);
  ctx.lineTo(S * 1.05, S * 0.7);
  ctx.lineTo(S * 0.8, S * 0.7);
  ctx.closePath();
  ctx.fill();
  ctx.stroke();

  // ── Belly gun ──
  ctx.fillStyle = '#ff6644';
  ctx.fillRect(-2, S * 0.5, 4, S * 0.3);
  // Gun barrel tip
  ctx.fillStyle = '#ff4422';
  ctx.fillRect(-1.5, S * 0.75, 3, 3);

  // ── Panel detail lines ──
  ctx.strokeStyle = '#8899aa';
  ctx.lineWidth = 0.5;
  ctx.beginPath();
  ctx.moveTo(-S * 0.4, -S * 0.1);
  ctx.lineTo(S * 0.4, -S * 0.1);
  ctx.moveTo(-S * 0.5, S * 0.2);
  ctx.lineTo(S * 0.5, S * 0.2);
  ctx.stroke();

  ctx.restore();
}

function drawHUD() {
  const cfg = ROUNDS[currentRound];
  const panelY = WORLD_BOTTOM;

  // Cockpit panel background — metallic gradient
  const panelGrad = ctx.createLinearGradient(0, panelY, 0, H);
  panelGrad.addColorStop(0, '#2a2a3e');
  panelGrad.addColorStop(0.15, '#1a1a2e');
  panelGrad.addColorStop(0.85, '#141428');
  panelGrad.addColorStop(1, '#0e0e1e');
  ctx.fillStyle = panelGrad;
  ctx.fillRect(0, panelY, W, HUD_HEIGHT);

  // Top bezel — bright edge
  ctx.strokeStyle = '#556';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(0, panelY); ctx.lineTo(W, panelY);
  ctx.stroke();
  ctx.strokeStyle = '#223';
  ctx.beginPath();
  ctx.moveTo(0, panelY + 2); ctx.lineTo(W, panelY + 2);
  ctx.stroke();

  // Rivet dots along top edge
  ctx.fillStyle = '#445';
  for (let rx = 20; rx < W; rx += 40) {
    ctx.beginPath();
    ctx.arc(rx, panelY + 6, 1.5, 0, Math.PI * 2);
    ctx.fill();
  }

  // Vertical dividers for 3-column layout
  const div1x = 135, div2x = W - 85;
  ctx.strokeStyle = '#334';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(div1x, panelY + 10); ctx.lineTo(div1x, H - 8);
  ctx.moveTo(div2x, panelY + 10); ctx.lineTo(div2x, H - 8);
  ctx.stroke();

  // ── Left column: Fuel & Ammo ──
  const col1 = 15;
  const labelY = panelY + 20;

  // Round
  ctx.fillStyle = '#88aacc';
  ctx.font = '11px monospace';
  ctx.textAlign = 'left';
  ctx.fillText(`ROUND ${currentRound + 1}/${ROUNDS.length}`, col1, labelY);
  ctx.fillStyle = '#ffcc44';
  ctx.font = '9px monospace';
  ctx.fillText(`SCORE ${score}`, col1 + 60, labelY);

  // Fuel bar
  drawBar(col1, labelY + 10, 100, 10, ship.fuel / ship.maxFuel, '#00cc44', 'FUEL');

  // Ammo bar
  const ammoFrac = ship.maxAmmo > 0 ? ship.ammo / ship.maxAmmo : 0;
  drawBar(col1, labelY + 32, 100, 10, ammoFrac, '#ffaa00', 'AMMO');

  // Lives display
  ctx.fillStyle = '#88aacc';
  ctx.font = '9px monospace';
  ctx.fillText('LIVES', col1, labelY + 57);
  for (let li = 0; li < lives; li++) {
    ctx.fillStyle = '#44ff88';
    ctx.fillRect(col1 + 32 + li * 12, labelY + 50, 8, 8);
    ctx.strokeStyle = '#226644';
    ctx.lineWidth = 0.5;
    ctx.strokeRect(col1 + 32 + li * 12, labelY + 50, 8, 8);
  }

  // ── Center column: Flight data ──
  const col2 = W / 2;
  ctx.textAlign = 'center';
  ctx.fillStyle = '#88aacc';
  ctx.font = '10px monospace';

  ctx.fillText('V-SPD', col2 - 40, labelY + 12);
  ctx.fillStyle = Math.abs(ship.vy) > MAX_LAND_VY ? '#ff4444' : '#44ff88';
  ctx.font = '13px monospace';
  ctx.fillText(`${ship.vy.toFixed(1)}`, col2 - 40, labelY + 26);

  ctx.fillStyle = '#88aacc';
  ctx.font = '10px monospace';
  ctx.fillText('H-SPD', col2 + 40, labelY + 12);
  ctx.fillStyle = Math.abs(ship.vx) > MAX_LAND_VX ? '#ff4444' : '#44ff88';
  ctx.font = '13px monospace';
  ctx.fillText(`${ship.vx.toFixed(1)}`, col2 + 40, labelY + 26);

  // Thruster status
  ctx.fillStyle = '#88aacc';
  ctx.font = '10px monospace';
  ctx.fillText('THRUST', col2, labelY + 44);
  ctx.font = '13px monospace';
  const thrustStatus = (ship.thrustL && ship.thrustR) ? 'BOTH' :
                       ship.thrustL ? 'LEFT' :
                       ship.thrustR ? 'RIGHT' : '--';
  ctx.fillStyle = (ship.thrustL || ship.thrustR) ? '#ffaa44' : '#556677';
  ctx.fillText(thrustStatus, col2, labelY + 58);

  // Altitude
  const alt = Math.max(0, getTerrainY(ship.x) - (ship.y + SHIP_SIZE));
  ctx.fillStyle = '#88aacc';
  ctx.font = '10px monospace';
  ctx.fillText('ALT', col2 + 40, labelY + 44);
  ctx.fillStyle = '#44ff88';
  ctx.font = '13px monospace';
  ctx.fillText(`${Math.floor(alt)}`, col2 + 40, labelY + 58);

  // ── Right column: Radar ──
  const radarX = W - 70;
  const radarY = panelY + 15;
  const radarW = 55;
  const radarH = 55;
  drawRadar(radarX, radarY, radarW, radarH);

  // Mute indicator
  if (audioMuted) {
    ctx.fillStyle = '#666';
    ctx.font = '8px monospace';
    ctx.textAlign = 'right';
    ctx.fillText('MUTED [M]', W - 8, H - 5);
  }
}

function drawBar(x, y, w, h, frac, color, label) {
  frac = clamp(frac, 0, 1);
  ctx.fillStyle = '#88aacc';
  ctx.font = '9px monospace';
  ctx.textAlign = 'left';
  ctx.fillText(label, x, y);

  // Background
  ctx.fillStyle = '#112';
  ctx.fillRect(x, y + 3, w, h);

  // Fill
  ctx.fillStyle = color;
  ctx.fillRect(x, y + 3, w * frac, h);

  // Border
  ctx.strokeStyle = '#445';
  ctx.lineWidth = 1;
  ctx.strokeRect(x, y + 3, w, h);
}

function drawRadar(rx, ry, rw, rh) {
  // Background
  ctx.fillStyle = '#0a1a0a';
  ctx.fillRect(rx, ry, rw, rh);
  ctx.strokeStyle = '#1a3a1a';
  ctx.lineWidth = 1;
  ctx.strokeRect(rx, ry, rw, rh);

  // Grid lines
  ctx.strokeStyle = '#0f2f0f';
  ctx.beginPath();
  ctx.moveTo(rx + rw / 2, ry); ctx.lineTo(rx + rw / 2, ry + rh);
  ctx.moveTo(rx, ry + rh / 2); ctx.lineTo(rx + rw, ry + rh / 2);
  ctx.stroke();

  // Terrain mini
  ctx.strokeStyle = '#2a5a2a';
  ctx.lineWidth = 1;
  ctx.beginPath();
  for (let i = 0; i < terrainX.length; i += 3) {
    const mx = rx + (terrainX[i] / W) * rw;
    const my = ry + (terrainY[i] / WORLD_BOTTOM) * rh;
    if (i === 0) ctx.moveTo(mx, my);
    else ctx.lineTo(mx, my);
  }
  ctx.stroke();

  // Landing pad
  const padMX = rx + ((padLeft + padRight) / 2 / W) * rw;
  const padMY = ry + (getTerrainY((padLeft + padRight) / 2) / WORLD_BOTTOM) * rh;
  ctx.fillStyle = '#00ff88';
  ctx.fillRect(padMX - 2, padMY - 1, 4, 2);

  // Enemy dots
  for (let i = 0; i < MAX_ENEMIES; i++) {
    const e = enemies[i];
    if (!e.active || e.state === 'dying') continue;
    const emx = rx + (e.x / W) * rw;
    const emy = ry + (e.y / WORLD_BOTTOM) * rh;
    ctx.fillStyle = e.state === 'telegraph' ? '#44ff44' : '#ff4444';
    ctx.fillRect(emx - 1, emy - 1, 2, 2);
  }

  // Bomb dots
  for (let i = 0; i < MAX_BOMBS; i++) {
    const b = bombs[i];
    if (!b.active) continue;
    const bmx = rx + (b.x / W) * rw;
    const bmy = ry + (b.y / WORLD_BOTTOM) * rh;
    ctx.fillStyle = '#ff8800';
    ctx.fillRect(bmx, bmy, 1, 1);
  }

  // Ship dot
  const sx = rx + (ship.x / W) * rw;
  const sy = ry + (ship.y / WORLD_BOTTOM) * rh;
  ctx.fillStyle = '#ffffff';
  ctx.fillRect(sx - 1, sy - 1, 3, 3);

  // Label
  ctx.fillStyle = '#2a5a2a';
  ctx.font = '7px monospace';
  ctx.textAlign = 'center';
  ctx.fillText('RADAR', rx + rw / 2, ry + rh + 9);
}

function drawOverlay() {
  ctx.textAlign = 'center';

  if (state === STATE.TITLE) {
    // Darken
    ctx.fillStyle = 'rgba(0,0,0,0.7)';
    ctx.fillRect(0, 0, W, H);

    ctx.fillStyle = '#44ccff';
    ctx.font = 'bold 32px monospace';
    ctx.fillText('SPACE LANDER', W / 2, H * 0.25);

    ctx.fillStyle = '#88aacc';
    ctx.font = '12px monospace';
    if (isMobile) {
      ctx.fillText('Tap left side: Left booster', W / 2, H * 0.38);
      ctx.fillText('Tap right side: Right booster', W / 2, H * 0.42);
      ctx.fillText('Tap bottom panel: Fire weapons', W / 2, H * 0.46);
    } else {
      ctx.fillText('Left/Right: Side thrusters', W / 2, H * 0.38);
      ctx.fillText('Both or Up: Boost upward', W / 2, H * 0.42);
      ctx.fillText('Space: Fire weapons downward', W / 2, H * 0.46);
    }
    ctx.fillText('Land safely on the green pad!', W / 2, H * 0.50);
    if (!isMobile) ctx.fillText('M: Mute/Unmute', W / 2, H * 0.54);

    if (hiScore > 0) {
      ctx.fillStyle = '#ffcc44';
      ctx.font = '11px monospace';
      ctx.fillText(`High Score: ${hiScore}`, W / 2, H * 0.58);
    }

    ctx.fillStyle = '#ffcc44';
    ctx.font = '14px monospace';
    const blink = Math.sin(Date.now() * 0.004) > 0;
    if (blink) ctx.fillText(isMobile ? 'TAP TO START' : 'PRESS ENTER TO START', W / 2, H * 0.66);
  }

  if (state === STATE.ROUND_INTRO) {
    ctx.fillStyle = 'rgba(0,0,0,0.6)';
    ctx.fillRect(0, 0, W, WORLD_BOTTOM);

    ctx.fillStyle = '#44ccff';
    ctx.font = 'bold 28px monospace';
    ctx.fillText(`ROUND ${currentRound + 1}`, W / 2, WORLD_BOTTOM * 0.35);

    const cfg = ROUNDS[currentRound];
    ctx.fillStyle = '#88aacc';
    ctx.font = '11px monospace';
    ctx.fillText(`Fuel: ${cfg.fuel}  |  Lives: ${lives}`, W / 2, WORLD_BOTTOM * 0.45);
    if (cfg.enemyRate > 0 || cfg.padAlien) {
      ctx.fillStyle = '#ff8866';
      let warning = 'Enemies active!';
      if (cfg.requiredKills > 0) warning += ` Kill ${cfg.requiredKills} to land.`;
      if (cfg.padAlien) warning = 'Alien on pad! Clear it to land.';
      if (cfg.padAlien && cfg.requiredKills > 0) warning = `Clear pad + kill ${cfg.requiredKills} to land!`;
      ctx.fillText(warning, W / 2, WORLD_BOTTOM * 0.50);
    }

    ctx.fillStyle = '#ffcc44';
    ctx.font = '12px monospace';
    const blink = Math.sin(Date.now() * 0.004) > 0;
    if (blink) ctx.fillText(isMobile ? 'TAP TO CONTINUE' : 'PRESS ENTER', W / 2, WORLD_BOTTOM * 0.62);
  }

  if (state === STATE.LANDED) {
    ctx.fillStyle = '#00ff88';
    ctx.font = 'bold 24px monospace';
    ctx.fillText('LANDED!', W / 2, WORLD_BOTTOM * 0.35);

    ctx.fillStyle = '#88aacc';
    ctx.font = '11px monospace';
    ctx.fillText(`Round score: +${roundScore}`, W / 2, WORLD_BOTTOM * 0.44);
    ctx.fillText(`Total: ${score}`, W / 2, WORLD_BOTTOM * 0.50);

    ctx.fillStyle = '#ffcc44';
    ctx.font = '12px monospace';
    const blink = Math.sin(Date.now() * 0.004) > 0;
    if (blink) ctx.fillText(isMobile ? 'TAP TO CONTINUE' : (currentRound < ROUNDS.length - 1 ? 'PRESS ENTER FOR NEXT ROUND' : 'PRESS ENTER'), W / 2, WORLD_BOTTOM * 0.58);
  }

  if (state === STATE.CRASHED) {
    if (lives > 0) {
      // Still have lives — show crash + remaining
      ctx.fillStyle = '#ff4444';
      ctx.font = 'bold 24px monospace';
      ctx.fillText('CRASHED!', W / 2, WORLD_BOTTOM * 0.30);

      ctx.fillStyle = '#ff8866';
      ctx.font = '11px monospace';
      ctx.fillText(`Lives remaining: ${lives}`, W / 2, WORLD_BOTTOM * 0.40);

      ctx.fillStyle = '#ffcc44';
      ctx.font = '12px monospace';
      const blink = Math.sin(Date.now() * 0.004) > 0;
      if (blink) ctx.fillText(isMobile ? 'TAP TO RETRY' : 'PRESS ENTER TO RETRY', W / 2, WORLD_BOTTOM * 0.55);
    } else {
      // Game over — full screen overlay with tips
      ctx.fillStyle = 'rgba(0,0,0,0.75)';
      ctx.fillRect(0, 0, W, H);

      ctx.fillStyle = '#ff4444';
      ctx.font = 'bold 28px monospace';
      ctx.fillText('GAME OVER', W / 2, H * 0.18);

      ctx.fillStyle = '#88aacc';
      ctx.font = '13px monospace';
      ctx.fillText('Well played!', W / 2, H * 0.25);

      ctx.fillStyle = '#44ff88';
      ctx.font = '12px monospace';
      ctx.fillText(`Reached: Round ${currentRound + 1} of ${ROUNDS.length}`, W / 2, H * 0.32);
      ctx.fillText(`Score: ${score}`, W / 2, H * 0.37);
      ctx.fillText(`Enemies destroyed: ${enemiesKilled}`, W / 2, H * 0.42);

      if (score >= hiScore && score > 0) {
        ctx.fillStyle = '#ffcc44';
        ctx.font = 'bold 12px monospace';
        ctx.fillText('NEW HIGH SCORE!', W / 2, H * 0.48);
      } else {
        ctx.fillStyle = '#88aacc';
        ctx.font = '11px monospace';
        ctx.fillText(`Best: ${hiScore}`, W / 2, H * 0.48);
      }

      // Random tips (pick 3 based on a seeded selection)
      ctx.fillStyle = '#667799';
      ctx.font = '10px monospace';
      ctx.fillText('--- TIPS ---', W / 2, H * 0.57);
      ctx.fillStyle = '#8899bb';
      ctx.font = '9px monospace';
      const tipSeed = (score * 7 + currentRound * 13) % TIPS.length;
      for (let ti = 0; ti < 3; ti++) {
        const tip = TIPS[(tipSeed + ti) % TIPS.length];
        ctx.fillText(tip, W / 2, H * 0.62 + ti * 0.05 * H);
      }

      ctx.fillStyle = '#ffcc44';
      ctx.font = '12px monospace';
      const blink = Math.sin(Date.now() * 0.004) > 0;
      if (blink) ctx.fillText(isMobile ? 'TAP TO CONTINUE' : 'PRESS ENTER', W / 2, H * 0.85);
    }
  }

  if (state === STATE.WIN) {
    ctx.fillStyle = 'rgba(0,0,0,0.7)';
    ctx.fillRect(0, 0, W, H);

    ctx.fillStyle = '#ffcc44';
    ctx.font = 'bold 28px monospace';
    ctx.fillText('MISSION COMPLETE!', W / 2, H * 0.3);

    ctx.fillStyle = '#88aacc';
    ctx.font = '13px monospace';
    ctx.fillText('All 10 rounds cleared!', W / 2, H * 0.4);

    ctx.fillStyle = '#44ff88';
    ctx.fillText(`Final Score: ${score}`, W / 2, H * 0.46);
    ctx.fillStyle = '#88aacc';
    ctx.font = '11px monospace';
    ctx.fillText(`Enemies destroyed: ${enemiesKilled}`, W / 2, H * 0.51);
    if (score > hiScore) {
      ctx.fillStyle = '#ffcc44';
      ctx.fillText('NEW HIGH SCORE!', W / 2, H * 0.56);
    } else {
      ctx.fillText(`Best: ${hiScore}`, W / 2, H * 0.56);
    }

    ctx.fillStyle = '#ffcc44';
    ctx.font = '12px monospace';
    const blink = Math.sin(Date.now() * 0.004) > 0;
    if (blink) ctx.fillText(isMobile ? 'TAP TO CONTINUE' : 'PRESS ENTER', W / 2, H * 0.52);
  }
}

// ── Audio System ──
let audioCtx = null;
let masterGain = null;
let musicGain = null;
let sfxGain = null;
let audioMuted = false;
let musicPlaying = false;

function initAudio() {
  if (audioCtx) return;
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  masterGain = audioCtx.createGain();
  masterGain.gain.value = 0.35;
  masterGain.connect(audioCtx.destination);

  musicGain = audioCtx.createGain();
  musicGain.gain.value = 0.15;
  musicGain.connect(masterGain);

  sfxGain = audioCtx.createGain();
  sfxGain.gain.value = 0.5;
  sfxGain.connect(masterGain);
}

function toggleMute() {
  audioMuted = !audioMuted;
  if (masterGain) masterGain.gain.value = audioMuted ? 0 : 0.35;
}

function playTone(freq, dur, type, vol, dest) {
  if (!audioCtx) return;
  const now = audioCtx.currentTime;
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = type || 'square';
  o.frequency.setValueAtTime(freq, now);
  g.gain.setValueAtTime(vol || 0.3, now);
  g.gain.exponentialRampToValueAtTime(0.001, now + dur);
  o.connect(g);
  g.connect(dest || sfxGain);
  o.start(now);
  o.stop(now + dur);
}

function playToneAt(freq, dur, type, vol, startTime, dest) {
  if (!audioCtx) return;
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = type || 'square';
  o.frequency.setValueAtTime(freq, startTime);
  g.gain.setValueAtTime(vol || 0.3, startTime);
  g.gain.exponentialRampToValueAtTime(0.001, startTime + dur);
  o.connect(g);
  g.connect(dest || sfxGain);
  o.start(startTime);
  o.stop(startTime + dur);
}

function playNoise(dur, vol, dest) {
  if (!audioCtx) return;
  const now = audioCtx.currentTime;
  const buf = audioCtx.createBuffer(1, Math.floor(audioCtx.sampleRate * dur), audioCtx.sampleRate);
  const data = buf.getChannelData(0);
  for (let i = 0; i < data.length; i++) data[i] = Math.random() * 2 - 1;
  const src = audioCtx.createBufferSource();
  src.buffer = buf;
  const g = audioCtx.createGain();
  g.gain.setValueAtTime(vol || 0.2, now);
  g.gain.exponentialRampToValueAtTime(0.001, now + dur);
  src.connect(g);
  g.connect(dest || sfxGain);
  src.start(now);
}

// ── SFX ──
function sfxThrust() {
  if (!audioCtx) return;
  playNoise(0.06, 0.08);
  playTone(120 + Math.random() * 30, 0.05, 'sawtooth', 0.06);
}

function sfxRotate() {
  if (!audioCtx) return;
  playNoise(0.03, 0.04);
}

function sfxFire() {
  if (!audioCtx) return;
  playTone(900, 0.06, 'square', 0.15);
  playTone(600, 0.04, 'square', 0.1);
}

function sfxExplosion() {
  if (!audioCtx) return;
  playNoise(0.5, 0.3);
  playTone(60, 0.4, 'sine', 0.25);
  playTone(40, 0.6, 'sine', 0.15);
}

function sfxBombExplode() {
  if (!audioCtx) return;
  playNoise(0.3, 0.2);
  playTone(80, 0.25, 'sine', 0.15);
}

function sfxEnemyHit() {
  if (!audioCtx) return;
  playTone(300, 0.08, 'square', 0.12);
  playTone(200, 0.06, 'triangle', 0.08);
}

function sfxEnemyDie() {
  if (!audioCtx) return;
  playTone(400, 0.1, 'square', 0.15);
  playTone(200, 0.15, 'sawtooth', 0.1);
  playNoise(0.2, 0.12);
}

function sfxLanding() {
  if (!audioCtx) return;
  const now = audioCtx.currentTime;
  // Ascending arpeggio C-E-G-C
  playToneAt(262, 0.15, 'triangle', 0.2, now);
  playToneAt(330, 0.15, 'triangle', 0.2, now + 0.1);
  playToneAt(392, 0.15, 'triangle', 0.2, now + 0.2);
  playToneAt(523, 0.25, 'triangle', 0.25, now + 0.3);
}

function sfxCrash() {
  if (!audioCtx) return;
  playNoise(0.8, 0.35);
  playTone(50, 0.6, 'sine', 0.3);
  playTone(30, 0.8, 'sine', 0.2);
}

function sfxArm() {
  if (!audioCtx) return;
  playTone(800, 0.04, 'square', 0.1);
  playTone(1000, 0.04, 'square', 0.08);
}

function sfxTelegraph() {
  if (!audioCtx) return;
  playTone(600, 0.08, 'sine', 0.1);
  const now = audioCtx.currentTime;
  playToneAt(800, 0.08, 'sine', 0.1, now + 0.12);
}

function sfxBombShot() {
  if (!audioCtx) return;
  playTone(150, 0.12, 'sawtooth', 0.08);
  playTone(100, 0.08, 'square', 0.06);
}

// ── Synthwave Music Loop ──
let musicInterval = null;

function startMusic() {
  if (!audioCtx || musicPlaying) return;
  musicPlaying = true;

  // Create a simple repeating synthwave pattern
  const bpm = 110;
  const beatLen = 60 / bpm;
  const barLen = beatLen * 4;

  // Bass notes (A minor progression: Am - F - C - G)
  const bassNotes = [110, 87.3, 130.8, 98];
  // Arp notes
  const arpPatterns = [
    [220, 262, 330, 262], // Am
    [175, 220, 262, 220], // F
    [262, 330, 392, 330], // C
    [196, 247, 294, 247], // G
  ];

  let barIndex = 0;

  function playBar() {
    if (!audioCtx || !musicPlaying) return;
    const now = audioCtx.currentTime;
    const bi = barIndex % 4;

    // Bass drone
    const bassO = audioCtx.createOscillator();
    const bassG = audioCtx.createGain();
    bassO.type = 'sawtooth';
    bassO.frequency.setValueAtTime(bassNotes[bi], now);
    bassG.gain.setValueAtTime(0.06, now);
    bassG.gain.setValueAtTime(0.06, now + barLen * 0.8);
    bassG.gain.exponentialRampToValueAtTime(0.001, now + barLen * 0.95);
    // Low-pass filter for bass warmth
    const bassFilter = audioCtx.createBiquadFilter();
    bassFilter.type = 'lowpass';
    bassFilter.frequency.value = 200;
    bassO.connect(bassFilter);
    bassFilter.connect(bassG);
    bassG.connect(musicGain);
    bassO.start(now);
    bassO.stop(now + barLen);

    // Arp sequence (16th notes across the bar)
    const arp = arpPatterns[bi];
    for (let i = 0; i < 8; i++) {
      const noteTime = now + i * (barLen / 8);
      const noteFreq = arp[i % 4] * (i >= 4 ? 2 : 1);
      const arpO = audioCtx.createOscillator();
      const arpG = audioCtx.createGain();
      arpO.type = 'square';
      arpO.frequency.setValueAtTime(noteFreq, noteTime);
      arpG.gain.setValueAtTime(0.04, noteTime);
      arpG.gain.exponentialRampToValueAtTime(0.001, noteTime + beatLen * 0.4);
      // Filter for that 80s sound
      const arpFilter = audioCtx.createBiquadFilter();
      arpFilter.type = 'lowpass';
      arpFilter.frequency.value = 1500 + Math.sin(barIndex * 0.5 + i * 0.3) * 500;
      arpO.connect(arpFilter);
      arpFilter.connect(arpG);
      arpG.connect(musicGain);
      arpO.start(noteTime);
      arpO.stop(noteTime + beatLen * 0.45);
    }

    // Hi-hat pattern (8th notes)
    for (let i = 0; i < 8; i++) {
      const hatTime = now + i * (barLen / 8);
      const accent = i % 2 === 0 ? 0.03 : 0.015;
      const hatBuf = audioCtx.createBuffer(1, Math.floor(audioCtx.sampleRate * 0.04), audioCtx.sampleRate);
      const hatData = hatBuf.getChannelData(0);
      for (let j = 0; j < hatData.length; j++) hatData[j] = Math.random() * 2 - 1;
      const hatSrc = audioCtx.createBufferSource();
      hatSrc.buffer = hatBuf;
      const hatG = audioCtx.createGain();
      hatG.gain.setValueAtTime(accent, hatTime);
      hatG.gain.exponentialRampToValueAtTime(0.001, hatTime + 0.04);
      const hatFilter = audioCtx.createBiquadFilter();
      hatFilter.type = 'highpass';
      hatFilter.frequency.value = 8000;
      hatSrc.connect(hatFilter);
      hatFilter.connect(hatG);
      hatG.connect(musicGain);
      hatSrc.start(hatTime);
    }

    barIndex++;
  }

  // Play first bar immediately, then schedule repeating
  playBar();
  musicInterval = setInterval(playBar, barLen * 1000);
}

function stopMusic() {
  musicPlaying = false;
  if (musicInterval) {
    clearInterval(musicInterval);
    musicInterval = null;
  }
}

// Thrust sound throttle
let lastThrustSfx = 0;
let lastRotSfx = 0;

// ── Main Game Loop ──
const FIXED_DT = 1 / 60;
let accumulator = 0;
let lastTime = 0;

function gameLoop(timestamp) {
  let dt = (timestamp - lastTime) / 1000;
  if (lastTime === 0) dt = FIXED_DT;
  lastTime = timestamp;
  dt = Math.min(dt, 0.1); // prevent spiral of death

  accumulator += dt;
  while (accumulator >= FIXED_DT) {
    update(FIXED_DT);
    accumulator -= FIXED_DT;
  }

  draw();
  requestAnimationFrame(gameLoop);
}

function update(dt) {
  stateTimer += dt;
  updateShake(dt);

  if (state === STATE.PLAYING) {
    updatePlaying(dt);
  }
  if (state === STATE.CRASHED || state === STATE.LANDED) {
    updateParticles(dt);
  }
}

function draw() {
  // Clear
  ctx.fillStyle = '#08080f';
  ctx.fillRect(0, 0, W, H);

  if (state !== STATE.TITLE && state !== STATE.WIN) {
    ctx.save();
    ctx.translate(shakeX, shakeY);
    drawStars();
    drawTerrain();
    drawEnemies();
    drawBombs();
    drawBullets();
    drawParticles();
    drawShip();
    ctx.restore();
    drawHUD();
  }

  drawOverlay();
}

// ── Start ──
requestAnimationFrame(gameLoop);

</script>
</body>
</html>
