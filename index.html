<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=no">
<title>Space Lander</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
html,body{width:100%;height:100%;overflow:hidden;background:#000}
canvas{display:block;margin:0 auto;image-rendering:pixelated;touch-action:none;cursor:crosshair;max-width:100vw;max-height:100vh}
</style>
</head>
<body>
<canvas id="gc"></canvas>
<script>
'use strict';

/* ========================================================
   SPACE LANDER — Milestone 2: Scrolling World
   ======================================================== */

// ── Canvas Setup ──
const canvas = document.getElementById('gc');
const ctx = canvas.getContext('2d');
const W = 480, H = 720;
canvas.width = W; canvas.height = H;

function resize() {
  const ar = W / H;
  let cw = window.innerWidth, ch = window.innerHeight;
  if (cw / ch > ar) {
    canvas.style.height = ch + 'px';
    canvas.style.width = (ch * ar) + 'px';
  } else {
    canvas.style.width = cw + 'px';
    canvas.style.height = (cw / ar) + 'px';
  }
}
window.addEventListener('resize', resize);
resize();

// ── Utility Functions ──
function clamp(v, lo, hi) { return v < lo ? lo : v > hi ? hi : v; }
function lerp(a, b, t) { return a + (b - a) * t; }
function dist(x1, y1, x2, y2) { const dx = x2 - x1, dy = y2 - y1; return Math.sqrt(dx * dx + dy * dy); }
function hsl(h, s, l, a) { return a !== undefined ? `hsla(${h},${s}%,${l}%,${a})` : `hsl(${h},${s}%,${l}%)`; }
function degToRad(d) { return d * Math.PI / 180; }
function radToDeg(r) { return r * 180 / Math.PI; }

// ── Seeded PRNG (mulberry32) ──
function mulberry32(seed) {
  return function() {
    seed |= 0; seed = seed + 0x6D2B79F5 | 0;
    let t = Math.imul(seed ^ seed >>> 15, 1 | seed);
    t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  };
}

// ── Round Configuration (data-driven) ──
// requiredKills: must kill this many enemies before landing is allowed
// padAlien: if true, an alien patrols across the landing pad firing upward
// worldWidth: total horizontal world size in pixels (screen = 480px)
// padZone: 'center' = pad under spawn, 'screen' = pad on initial screen, 'anywhere' = pad hidden off-screen
const ROUNDS = [
  { round:1,  gravity:0.03, fuel:800, ammo:0,  padWidth:100,padPlacementRisk:0.0, terrainRoughness:0.08, terrainSeed:101, enemyRate:0,   enemyTypes:[],                  bombSpeed:0,   blastRadius:0,  requiredKills:0, padAlien:false, worldWidth:1440, padZone:'center',
    planetName:'The Moon', planetDesc:'Low gravity, smooth craters. A gentle start.', terrainColors:{top:'#888888',mid:'#666666',bot:'#444444',stroke:'#999999'} },
  { round:2,  gravity:0.035,fuel:700, ammo:0,  padWidth:90, padPlacementRisk:0.25,terrainRoughness:0.15, terrainSeed:217, enemyRate:0,   enemyTypes:[],                  bombSpeed:0,   blastRadius:0,  requiredKills:0, padAlien:false, worldWidth:1440, padZone:'screen',
    planetName:'Mars', planetDesc:'Red dust and rocky ridges. Watch your fuel.', terrainColors:{top:'#884422',mid:'#773318',bot:'#552211',stroke:'#aa5533'} },
  { round:3,  gravity:0.04, fuel:650, ammo:20, padWidth:80, padPlacementRisk:0.3, terrainRoughness:0.22, terrainSeed:318, enemyRate:0.7, enemyTypes:['turret'],          bombSpeed:2.0, blastRadius:25, requiredKills:0, padAlien:false, worldWidth:1680, padZone:'screen',
    planetName:'Europa', planetDesc:'Frozen ice fields. Hostile turrets detected!', terrainColors:{top:'#556688',mid:'#445577',bot:'#334466',stroke:'#6688aa'} },
  { round:4,  gravity:0.04, fuel:800, ammo:25, padWidth:74, padPlacementRisk:0.35,terrainRoughness:0.28, terrainSeed:419, enemyRate:0.8, enemyTypes:['turret','alien'],  bombSpeed:2.2, blastRadius:28, requiredKills:0, padAlien:false, worldWidth:1920, padZone:'anywhere',
    planetName:'Venus', planetDesc:'Thick atmosphere, hidden landing zone. Explore!', terrainColors:{top:'#887744',mid:'#776633',bot:'#554422',stroke:'#aa9955'} },
  { round:5,  gravity:0.05, fuel:850, ammo:30, padWidth:68, padPlacementRisk:0.4, terrainRoughness:0.32, terrainSeed:520, enemyRate:0.9, enemyTypes:['turret','alien'],  bombSpeed:2.4, blastRadius:30, requiredKills:0, padAlien:true,  worldWidth:2160, padZone:'anywhere',
    planetName:'Titan', planetDesc:'Orange haze and hostile aliens guard the pad.', terrainColors:{top:'#885522',mid:'#774411',bot:'#553300',stroke:'#aa6633'} },
  { round:6,  gravity:0.05, fuel:900, ammo:35, padWidth:62, padPlacementRisk:0.45,terrainRoughness:0.36, terrainSeed:621, enemyRate:1.0, enemyTypes:['turret','alien'],  bombSpeed:2.6, blastRadius:32, requiredKills:1, padAlien:true,  worldWidth:2400, padZone:'anywhere',
    planetName:'Mercury', planetDesc:'Scorched surface. Kill 1 guard to land.', terrainColors:{top:'#666055',mid:'#555044',bot:'#444033',stroke:'#887766'} },
  { round:7,  gravity:0.06, fuel:950, ammo:35, padWidth:56, padPlacementRisk:0.45,terrainRoughness:0.40, terrainSeed:722, enemyRate:0.8, enemyTypes:['turret','alien'],  bombSpeed:2.6, blastRadius:35, requiredKills:1, padAlien:true,  worldWidth:2880, padZone:'anywhere',
    planetName:'Io', planetDesc:'Sulphur volcanoes and strong gravity. Stay sharp!', terrainColors:{top:'#888833',mid:'#777722',bot:'#555511',stroke:'#aaaa44'} },
  { round:8,  gravity:0.06, fuel:950, ammo:35, padWidth:50, padPlacementRisk:0.45,terrainRoughness:0.44, terrainSeed:823, enemyRate:0.9, enemyTypes:['turret','alien'],  bombSpeed:2.8, blastRadius:38, requiredKills:1, padAlien:true,  worldWidth:3120, padZone:'anywhere',
    planetName:'Ceres', planetDesc:'Dark dwarf planet. Tiny pad, heavy resistance.', terrainColors:{top:'#554466',mid:'#443355',bot:'#332244',stroke:'#665577'} },
  { round:9,  gravity:0.07, fuel:1000,ammo:40, padWidth:46, padPlacementRisk:0.35,terrainRoughness:0.48, terrainSeed:942, enemyRate:1.0, enemyTypes:['turret','alien'],  bombSpeed:3.0, blastRadius:40, requiredKills:2, padAlien:true,  worldWidth:3360, padZone:'anywhere',
    planetName:'Pluto', planetDesc:'Freezing wasteland. Kill 2 guards to land.', terrainColors:{top:'#667788',mid:'#556677',bot:'#445566',stroke:'#7799aa'} },
  { round:10, gravity:0.07, fuel:1000,ammo:45, padWidth:42, padPlacementRisk:0.45,terrainRoughness:0.52, terrainSeed:1043,enemyRate:1.1, enemyTypes:['turret','alien'],  bombSpeed:3.2, blastRadius:42, requiredKills:2, padAlien:true,  worldWidth:3360, padZone:'anywhere',
    planetName:'Planet X', planetDesc:'Volcanic hellscape. The final challenge!', terrainColors:{top:'#662222',mid:'#551111',bot:'#330808',stroke:'#883333'} },
];

// ── Tips (shown on game over screen) ──
const TIPS = [
  'Hold both L+R or Up to hover in place',
  'Tap thrusters in short bursts to save fuel',
  'Kill the red pad alien before attempting to land',
  'Watch the radar to track incoming bombs',
  'Shoot enemy bombs out of the air with Space',
  'Later rounds require enemy kills before landing',
  'Press Space (or FIRE on mobile) to shoot downward',
  'Counter-thrust early to stop horizontal drift',
  'The V-SPD and H-SPD gauges turn red when unsafe',
  'You gain an extra life for each successful landing',
  'Bullets fire downward — hover above enemies to hit them',
  'Use short taps, not long holds, for precise control',
  'Check the radar — the green dot is the landing pad',
  'In later rounds the pad is hidden, explore to find it',
];

// ── Landing Thresholds (constant across rounds) ──
const MAX_LAND_VY = 2.2;    // max downward speed to survive (lenient)
const MAX_LAND_VX = 1.2;    // max horizontal speed (lenient)

// ── Game World Constants ──
const WORLD_TOP = 0;
const HUD_HEIGHT = 150;
const WORLD_BOTTOM = H - HUD_HEIGHT;  // terrain lives in top 570px
let terrainPointCount = 120;          // recalculated per round based on world width
const SHIP_SIZE = 14;                 // half-size of ship

// ── Scrolling World & Camera ──
let worldWidth = 480;                 // current round's world width (set per round)
let cameraX = 0;                      // current camera horizontal offset
const DEAD_ZONE = 0.3;              // ship can move freely in central 60% (0.3 from each edge)
const CAMERA_EDGE_SMOOTH = 0.12;    // how fast camera catches up when outside dead zone
const WORLD_EDGE_MARGIN = 2;         // wall collision margin at world edges

// ── Game State ──
const STATE = { TITLE: 0, PLAYING: 1, LANDED: 2, CRASHED: 3, WIN: 4, ROUND_INTRO: 5 };
let state = STATE.TITLE;
let currentRound = 0; // 0-indexed into ROUNDS
let stateTimer = 0;
let score = 0;
let roundScore = 0;
let enemiesKilled = 0;
let roundKills = 0;      // kills this round (for required-kill check)
let lives = 3;
const MAX_LIVES = 6;
let hiScore = parseInt(localStorage.getItem('spaceLanderHi') || '0', 10);

// ── Ship State ──
let ship = {};

// ── Astronaut Animation ──
let astro = { phase:0, timer:0, x:0, y:0, targetX:0, legFrame:0, flagX:0, flagY:0, flagHeight:0 };
// phase: 0=inactive, 1=emerge, 2=walk, 3=plant, 4=done
function resetShip() {
  ship = {
    x: worldWidth / 2,
    y: 60,
    vx: 0,
    vy: 0,
    fuel: ROUNDS[currentRound].fuel,
    maxFuel: ROUNDS[currentRound].fuel,
    ammo: ROUNDS[currentRound].ammo,
    maxAmmo: ROUNDS[currentRound].ammo,
    health: 100,
    maxHealth: 100,
    thrustL: false,  // left thruster active
    thrustR: false,  // right thruster active
    armed: true,
  };
}

// ── Terrain ──
let terrainX = [];
let terrainY = [];
let padLeft = 0, padRight = 0; // x coords of landing pad edges

function generateTerrain(roundCfg) {
  const rng = mulberry32(roundCfg.terrainSeed);
  const rough = roundCfg.terrainRoughness;
  const ww = worldWidth;
  const n = Math.floor(ww / 4); // ~1 point per 4px, scales with world width
  terrainPointCount = n;
  terrainX = [];
  terrainY = [];

  // Base terrain using midpoint displacement
  const baseY = WORLD_BOTTOM - 60; // baseline near bottom of world
  const heights = new Array(n + 1);

  // Start with endpoints
  heights[0] = baseY - rng() * 80;
  heights[n] = baseY - rng() * 80;

  // Midpoint displacement
  function displace(l, r, depth) {
    if (r - l <= 1) return;
    const mid = Math.floor((l + r) / 2);
    const avg = (heights[l] + heights[r]) / 2;
    const range = (r - l) / n * 300 * rough;
    heights[mid] = avg + (rng() - 0.5) * range;
    // Clamp terrain to world
    heights[mid] = clamp(heights[mid], WORLD_BOTTOM - 350, WORLD_BOTTOM - 30);
    displace(l, mid, depth + 1);
    displace(mid, r, depth + 1);
  }
  displace(0, n, 0);

  // Fill in any undefined (shouldn't happen, but safety)
  for (let i = 0; i <= n; i++) {
    if (heights[i] === undefined) heights[i] = baseY;
  }

  // Place landing pad based on padZone:
  // 'center'  = directly under spawn (worldWidth/2)
  // 'screen'  = within initial screen view but offset from center
  // 'anywhere' = anywhere in the world (hidden, must explore)
  const padW = roundCfg.padWidth;
  const segW = ww / n;
  const spawnX = ww / 2; // ship spawn position
  const spawnScreenLeft = spawnX - W / 2;
  const spawnScreenRight = spawnX + W / 2;

  const wallBuffer = 8; // keep pad away from world edges (in segments)
  const candidates = [];
  for (let i = wallBuffer; i < n - wallBuffer; i++) {
    const slope = Math.abs(heights[Math.min(i+1, n)] - heights[Math.max(i-1, 0)]) / (2 * segW);
    const xPos = i * segW;

    // Skip positions too close to world edge walls
    if (xPos < padW + 15 || xPos > ww - padW - 15) continue;

    // Filter by padZone
    if (roundCfg.padZone === 'center') {
      // Must be very close to spawn center
      if (Math.abs(xPos - spawnX) > 40) continue;
    } else if (roundCfg.padZone === 'screen') {
      // Must be within the initial screen view, but not dead center
      if (xPos < spawnScreenLeft + 40 || xPos > spawnScreenRight - 40) continue;
      if (Math.abs(xPos - spawnX) < 60) continue; // not directly under spawn
    } else { // 'anywhere'
      // Must be OFF the initial screen (hidden)
      if (xPos >= spawnScreenLeft - 20 && xPos <= spawnScreenRight + 20) continue;
    }

    const centerDist = Math.abs(i - n / 2) / (n / 2); // 0=center, 1=edge
    const difficulty = slope * 0.6 + centerDist * 0.4;
    candidates.push({ i, difficulty });
  }
  candidates.sort((a, b) => a.difficulty - b.difficulty);

  // Fallback: if no candidates found for the zone, relax to any valid spot
  if (candidates.length === 0) {
    for (let i = wallBuffer; i < n - wallBuffer; i++) {
      const xPos = i * segW;
      if (xPos < padW + 15 || xPos > ww - padW - 15) continue;
      candidates.push({ i, difficulty: 0 });
    }
  }

  // Pick candidate based on padPlacementRisk (0=easiest, 1=hardest)
  const pickIdx = Math.floor(roundCfg.padPlacementRisk * (candidates.length - 1) * 0.8);
  const chosen = candidates[clamp(pickIdx, 0, candidates.length - 1)];
  const padCenterI = chosen.i;

  // Flatten the pad area
  const padSegs = Math.ceil(padW / segW);
  const padStartI = clamp(padCenterI - Math.floor(padSegs / 2), 1, n - padSegs - 1);
  const padEndI = padStartI + padSegs;
  const padYVal = heights[padCenterI];

  for (let i = padStartI; i <= padEndI; i++) {
    heights[i] = padYVal;
  }

  padLeft = padStartI * segW;
  padRight = padEndI * segW;

  // Build terrain arrays
  for (let i = 0; i <= n; i++) {
    terrainX.push(i * segW);
    terrainY.push(heights[i]);
  }
}

// Get terrain height at any x via linear interpolation
function getTerrainY(x) {
  if (x <= 0) return terrainY[0];
  if (x >= worldWidth) return terrainY[terrainY.length - 1];
  const segW = worldWidth / terrainPointCount;
  const i = x / segW;
  const lo = Math.floor(i);
  const hi = Math.min(lo + 1, terrainY.length - 1);
  const t = i - lo;
  return lerp(terrainY[lo], terrainY[hi], t);
}

// ── Stars (background) ──
let stars = [];
function generateStars() {
  stars = [];
  // Stars cover the parallax visible range: at 0.3x scroll,
  // max visible x = W + (worldWidth - W) * 0.3
  const starFieldWidth = W + (worldWidth - W) * 0.3;
  const starCount = Math.floor(80 * (starFieldWidth / W));
  for (let i = 0; i < starCount; i++) {
    stars.push({
      x: Math.random() * starFieldWidth,
      y: Math.random() * WORLD_BOTTOM,
      size: Math.random() * 1.5 + 0.5,
      bright: Math.random() * 0.5 + 0.5,
    });
  }
}
generateStars();

// ── Input ──
const keys = {};
document.addEventListener('keydown', e => {
  keys[e.code] = true;
  // Prevent scrolling with arrow keys / space
  if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','Space'].includes(e.code)) {
    e.preventDefault();
  }
  handleKeyAction(e.code, true);
});
document.addEventListener('keyup', e => {
  keys[e.code] = false;
});

function handleKeyAction(code, down) {
  if (!down) return;
  initAudio();
  if (code === 'KeyM') toggleMute();
  if (state === STATE.TITLE && (code === 'Space' || code === 'Enter')) {
    startGame();
    startMusic();
  }
  if (state === STATE.ROUND_INTRO && (code === 'Space' || code === 'Enter')) {
    state = STATE.PLAYING;
  }
  if ((state === STATE.LANDED) && (code === 'Space' || code === 'Enter')) {
    if (astro.phase < 4) return; // wait for astronaut animation
    nextRound();
  }
  if ((state === STATE.CRASHED) && (code === 'Space' || code === 'Enter')) {
    if (lives <= 0 && stateTimer < 2.5) return; // wait for game over animation
    restartRound();
  }
  if (state === STATE.WIN && (code === 'Space' || code === 'Enter')) {
    if (stateTimer < 3.5) return; // wait for celebration
    state = STATE.TITLE;
  }
  // Fire
  if (state === STATE.PLAYING && code === 'Space') {
    fireBullet();
  }
}

// ── Touch Controls ──
let touchThrust = false, touchLeft = false, touchRight = false;
let touchFire = false;
let isMobile = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);

// Touch zones: left half = left booster, right half = right booster, bottom panel = fire
const PANEL_ZONE = WORLD_BOTTOM / H; // ~0.792 — everything below this is the HUD/fire zone

canvas.addEventListener('touchstart', e => { e.preventDefault(); handleTouchEvent(e); }, { passive: false });
canvas.addEventListener('touchmove', e => { e.preventDefault(); handleTouchEvent(e); }, { passive: false });
canvas.addEventListener('touchend', e => { e.preventDefault(); handleTouchEvent(e); }, { passive: false });
canvas.addEventListener('touchcancel', e => {
  e.preventDefault();
  touchThrust = false; touchLeft = false; touchRight = false; touchFire = false;
}, { passive: false });

function handleTouchEvent(e) {
  isMobile = true;
  initAudio();

  // Reset all touch states, then check active touches
  touchThrust = false; touchLeft = false; touchRight = false; touchFire = false;
  const r = canvas.getBoundingClientRect();

  for (let i = 0; i < e.touches.length; i++) {
    const tx = (e.touches[i].clientX - r.left) / r.width;
    const ty = (e.touches[i].clientY - r.top) / r.height;

    if (ty >= PANEL_ZONE) {
      // Bottom panel = fire
      touchFire = true;
    } else if (tx < 0.5) {
      // Left half of game area = left booster
      touchLeft = true;
    } else {
      // Right half of game area = right booster
      touchRight = true;
    }
  }

  // Tap to advance state
  if (e.type === 'touchstart') {
    if (state === STATE.TITLE) { startGame(); startMusic(); return; }
    if (state === STATE.ROUND_INTRO) { state = STATE.PLAYING; return; }
    if (state === STATE.LANDED) { if (astro.phase < 4) return; nextRound(); return; }
    if (state === STATE.CRASHED) { if (lives <= 0 && stateTimer < 2.5) return; restartRound(); return; }
    if (state === STATE.WIN) { if (stateTimer < 3.5) return; state = STATE.TITLE; return; }
  }
}

// ── Screen Shake ──
let shakeX = 0, shakeY = 0, shakeMag = 0;

function triggerShake(mag) {
  shakeMag = Math.max(shakeMag, mag);
}

function updateShake(dt) {
  if (shakeMag > 0) {
    shakeMag = Math.max(0, shakeMag - dt * 30);
    shakeX = (Math.random() - 0.5) * shakeMag;
    shakeY = (Math.random() - 0.5) * shakeMag;
  } else {
    shakeX = 0; shakeY = 0;
  }
}

// ── Camera ──
function updateCamera() {
  if (ship.x === undefined) return; // not initialized yet (title screen)

  // Dead zone camera: ship moves freely in the central 60% of the screen.
  // Camera only scrolls when the ship pushes past the dead zone edges.
  const screenX = ship.x - cameraX; // ship position relative to screen
  const leftEdge = W * DEAD_ZONE;   // ~144px from left
  const rightEdge = W * (1 - DEAD_ZONE); // ~336px from left

  let targetX = cameraX;
  if (screenX < leftEdge) {
    // Ship is past the left dead zone edge — push camera left
    targetX = ship.x - leftEdge;
  } else if (screenX > rightEdge) {
    // Ship is past the right dead zone edge — push camera right
    targetX = ship.x - rightEdge;
  }

  // Clamp so camera doesn't show beyond world edges
  targetX = clamp(targetX, 0, Math.max(0, worldWidth - W));

  // Smooth transition (not instant, but responsive)
  cameraX += (targetX - cameraX) * CAMERA_EDGE_SMOOTH;
  if (Math.abs(cameraX - targetX) < 0.5) cameraX = targetX;
}

// ── Particles (simple pool) ──
const MAX_PARTICLES = 300;
const particles = [];
for (let i = 0; i < MAX_PARTICLES; i++) {
  particles.push({ active: false, x:0, y:0, vx:0, vy:0, life:0, maxLife:0, r:0, color:'', type:0 });
}

function spawnParticle(x, y, vx, vy, life, r, color, type) {
  for (let i = 0; i < MAX_PARTICLES; i++) {
    if (!particles[i].active) {
      const p = particles[i];
      p.active = true; p.x = x; p.y = y; p.vx = vx; p.vy = vy;
      p.life = life; p.maxLife = life; p.r = r; p.color = color; p.type = type || 0;
      return p;
    }
  }
  return null;
}

function updateParticles(dt) {
  for (let i = 0; i < MAX_PARTICLES; i++) {
    const p = particles[i];
    if (!p.active) continue;
    p.x += p.vx * dt * 60;
    p.y += p.vy * dt * 60;
    p.life -= dt;
    if (p.life <= 0) p.active = false;
  }
}

function drawParticles() {
  for (let i = 0; i < MAX_PARTICLES; i++) {
    const p = particles[i];
    if (!p.active) continue;
    const alpha = clamp(p.life / p.maxLife, 0, 1);
    ctx.globalAlpha = alpha;
    ctx.fillStyle = p.color;
    ctx.fillRect(p.x - p.r, p.y - p.r, p.r * 2, p.r * 2);
  }
  ctx.globalAlpha = 1;
}

function clearParticles() {
  for (let i = 0; i < MAX_PARTICLES; i++) particles[i].active = false;
}

// ── Bullets (Player Projectiles) ──
const MAX_BULLETS = 30;
const bullets = [];
for (let i = 0; i < MAX_BULLETS; i++) {
  bullets.push({ active: false, x:0, y:0, vx:0, vy:0, life:0 });
}
const BULLET_SPEED = 6;
const BULLET_LIFE = 1.5; // seconds
let fireTimer = 0;
const FIRE_RATE = 0.12; // seconds between shots

function fireBullet() {
  if (ship.ammo <= 0) return;
  if (fireTimer > 0) return;
  fireTimer = FIRE_RATE;
  ship.ammo--;
  sfxFire();

  for (let i = 0; i < MAX_BULLETS; i++) {
    if (!bullets[i].active) {
      const b = bullets[i];
      b.active = true;
      // Fire downward from belly of ship
      b.x = ship.x;
      b.y = ship.y + SHIP_SIZE;
      // Slight aim based on active thrusters (moving left = bullets angle slightly left)
      const aimX = ship.vx * 0.15;
      b.vx = aimX;
      b.vy = BULLET_SPEED;
      b.life = BULLET_LIFE;
      return;
    }
  }
}

function updateBullets(dt) {
  fireTimer = Math.max(0, fireTimer - dt);

  for (let i = 0; i < MAX_BULLETS; i++) {
    const b = bullets[i];
    if (!b.active) continue;
    b.x += b.vx * dt * 60;
    b.y += b.vy * dt * 60;
    b.life -= dt;

    // Off-screen or expired
    if (b.life <= 0 || b.x < -10 || b.x > worldWidth + 10 || b.y < -10 || b.y > H + 10) {
      b.active = false;
      continue;
    }

    // Terrain collision
    if (b.y >= getTerrainY(b.x)) {
      b.active = false;
      // Spark particles
      for (let j = 0; j < 4; j++) {
        spawnParticle(b.x, b.y,
          (Math.random() - 0.5) * 2, -Math.random() * 2,
          0.15, 1, '#ffcc44', 0);
      }
      continue;
    }

    // Enemy collision
    let bulletHit = false;
    for (let j = 0; j < MAX_ENEMIES; j++) {
      const e = enemies[j];
      if (!e.active || e.state !== 'active') continue;
      const hitDist = e.type === 'turret' ? 12 : 12;
      if (dist(b.x, b.y, e.x, e.y - 5) < hitDist) {
        e.hp--;
        if (e.hp <= 0) {
          e.state = 'dying';
          e.stateTimer = 0;
          spawnExplosion(e.x, e.y);
          enemiesKilled++;
          roundKills++;
          score += e.type === 'turret' ? 100 : e.type === 'padAlien' ? 300 : 200;
          sfxEnemyDie();
        } else {
          sfxEnemyHit();
        }
        bulletHit = true;
        break;
      }
    }
    if (bulletHit) { b.active = false; continue; }

    // Bomb collision (shoot down bombs)
    for (let j = 0; j < MAX_BOMBS; j++) {
      const bm = bombs[j];
      if (!bm.active) continue;
      if (dist(b.x, b.y, bm.x, bm.y) < 8) {
        bm.active = false;
        b.active = false;
        // Small pop
        for (let k = 0; k < 6; k++) {
          spawnParticle(bm.x, bm.y,
            (Math.random()-0.5)*2, (Math.random()-0.5)*2,
            0.2, 1.5, '#ffaa00', 0);
        }
        bulletHit = true;
        break;
      }
    }
    if (bulletHit) continue;
  }
}

function drawBullets() {
  ctx.fillStyle = '#ffff44';
  for (let i = 0; i < MAX_BULLETS; i++) {
    const b = bullets[i];
    if (!b.active) continue;
    ctx.fillRect(b.x - 1.5, b.y - 1.5, 3, 3);
    // Trail
    ctx.globalAlpha = 0.4;
    ctx.fillRect(b.x - b.vx * 0.1 - 1, b.y - b.vy * 0.1 - 1, 2, 2);
    ctx.globalAlpha = 1;
  }
}

function clearBullets() {
  for (let i = 0; i < MAX_BULLETS; i++) bullets[i].active = false;
}

// ── Enemies ──
const MAX_ENEMIES = 12;
const enemies = [];
for (let i = 0; i < MAX_ENEMIES; i++) {
  enemies.push({
    active: false,
    type: 'turret', // 'turret' or 'alien'
    x: 0, y: 0,
    vx: 0, vy: 0,
    hp: 1, maxHp: 1,
    state: 'telegraph', // 'telegraph', 'active', 'dying'
    stateTimer: 0,
    fireTimer: 0,
    patrolDir: 1,
    patrolRange: 60,
    originX: 0,
  });
}

let enemySpawnTimer = 0;
let enemiesSpawned = 0;

// ── Bombs (Enemy Projectiles) ──
const MAX_BOMBS = 20;
const bombs = [];
for (let i = 0; i < MAX_BOMBS; i++) {
  bombs.push({ active: false, x:0, y:0, vx:0, vy:0, life:0 });
}

function spawnEnemy(type) {
  for (let i = 0; i < MAX_ENEMIES; i++) {
    if (!enemies[i].active) {
      const e = enemies[i];
      e.active = true;
      e.type = type;
      e.state = 'telegraph';
      e.stateTimer = 0;
      sfxTelegraph();

      if (type === 'turret') {
        // Place on terrain, avoiding the landing pad
        let ex;
        do {
          ex = 30 + Math.random() * (worldWidth - 60);
        } while (ex > padLeft - 30 && ex < padRight + 30);
        e.x = ex;
        e.y = getTerrainY(ex);
        e.vx = 0; e.vy = 0;
        e.hp = 1 + Math.floor(Math.random() * 2); // 1-2 HP
        e.maxHp = e.hp;
        e.fireTimer = 1.5 + Math.random() * 2;
      } else { // alien
        e.x = Math.random() < 0.5 ? -10 : worldWidth + 10;
        e.y = 60 + Math.random() * (WORLD_BOTTOM * 0.4);
        e.vx = e.x < 0 ? 0.8 : -0.8;
        e.vy = 0;
        e.hp = 2 + Math.floor(Math.random() * 2); // 2-3 HP
        e.maxHp = e.hp;
        e.fireTimer = 2 + Math.random() * 2;
        e.patrolDir = e.vx > 0 ? 1 : -1;
        e.originX = e.x;
        e.patrolRange = 80 + Math.random() * 60;
      }
      return;
    }
  }
}

function spawnPadAlien() {
  for (let i = 0; i < MAX_ENEMIES; i++) {
    if (!enemies[i].active) {
      const e = enemies[i];
      e.active = true;
      e.type = 'padAlien';
      e.state = 'telegraph';
      e.stateTimer = 0;
      sfxTelegraph();
      // Start at one end of the pad
      const padMid = (padLeft + padRight) / 2;
      const padY = getTerrainY(padMid);
      e.x = padLeft;
      e.y = padY - 10; // just above pad surface
      e.vx = 0.5;
      e.vy = 0;
      e.hp = 2;
      e.maxHp = 2;
      e.fireTimer = 1.5;
      e.originX = padMid;
      e.patrolRange = (padRight - padLeft) / 2;
      e.patrolDir = 1;
      return;
    }
  }
}

// Spawn turret guards near the landing pad for required-kill rounds.
// Places them on the terrain flanking the pad so the player knows where to look.
function spawnPadGuards(count) {
  const padMid = (padLeft + padRight) / 2;
  const padW = padRight - padLeft;
  for (let g = 0; g < count; g++) {
    for (let i = 0; i < MAX_ENEMIES; i++) {
      if (!enemies[i].active) {
        const e = enemies[i];
        e.active = true;
        e.type = 'turret';
        e.state = 'telegraph';
        e.stateTimer = 0;
        // Place on alternating sides of the pad, close by
        const side = (g % 2 === 0) ? -1 : 1;
        const offset = padW * 0.8 + 30 + g * 25; // just outside the pad
        e.x = clamp(padMid + side * offset, 30, worldWidth - 30);
        e.y = getTerrainY(e.x);
        e.vx = 0; e.vy = 0;
        e.hp = 2;
        e.maxHp = 2;
        e.fireTimer = 2 + Math.random() * 1.5;
        e.patrolDir = 1;
        e.originX = e.x;
        e.patrolRange = 0;
        break;
      }
    }
  }
}

function fireBombDir(ex, ey, vx, vy) {
  sfxBombShot();
  for (let i = 0; i < MAX_BOMBS; i++) {
    if (!bombs[i].active) {
      const b = bombs[i];
      b.active = true;
      b.x = ex; b.y = ey;
      b.vx = vx; b.vy = vy;
      b.life = 3;
      return;
    }
  }
}

function fireBomb(ex, ey) {
  sfxBombShot();
  const cfg = ROUNDS[currentRound];
  for (let i = 0; i < MAX_BOMBS; i++) {
    if (!bombs[i].active) {
      const b = bombs[i];
      b.active = true;
      b.x = ex; b.y = ey;
      // Aim at player — lead the target slightly
      const dx = ship.x + ship.vx * 15 - ex;
      const dy = ship.y + ship.vy * 10 - ey;
      const d = Math.sqrt(dx * dx + dy * dy) || 1;
      const speed = Math.max(cfg.bombSpeed, 1.8); // minimum speed so bombs fly far
      b.vx = (dx / d) * speed + (Math.random() - 0.5) * 0.4;
      b.vy = (dy / d) * speed + (Math.random() - 0.5) * 0.4;
      b.life = 5;
      return;
    }
  }
}

function updateEnemies(dt) {
  const cfg = ROUNDS[currentRound];

  // Spawn timer
  if (cfg.enemyRate > 0) {
    enemySpawnTimer -= dt;
    if (enemySpawnTimer <= 0) {
      // Pick a random enemy type from available types
      const types = cfg.enemyTypes;
      if (types.length > 0) {
        const type = types[Math.floor(Math.random() * types.length)];
        spawnEnemy(type);
        enemiesSpawned++;
      }
      // Next spawn interval (inversely proportional to rate)
      enemySpawnTimer = (3 + Math.random() * 3) / cfg.enemyRate;
    }
  }

  for (let i = 0; i < MAX_ENEMIES; i++) {
    const e = enemies[i];
    if (!e.active) continue;

    e.stateTimer += dt;

    if (e.state === 'telegraph') {
      // Green head visible for 1 second, then activate
      if (e.stateTimer >= 1.0) {
        e.state = 'active';
        e.stateTimer = 0;
        if (e.type === 'alien') {
          e.originX = e.x; // reset patrol origin once active
        }
      }
      continue; // Don't move or shoot while telegraphing
    }

    if (e.state === 'dying') {
      if (e.stateTimer >= 0.3) {
        e.active = false;
      }
      continue;
    }

    // Active behavior
    if (e.type === 'turret') {
      // Stationary, just fire
      e.fireTimer -= dt;
      if (e.fireTimer <= 0) {
        fireBomb(e.x, e.y - 8);
        e.fireTimer = 2 + Math.random() * 1.5;
      }
    } else if (e.type === 'padAlien') {
      // Patrol across the landing pad, fire upward
      e.x += e.vx * dt * 60;
      // Bounce within pad bounds
      if (e.x <= padLeft + 5 || e.x >= padRight - 5) {
        e.vx *= -1;
        e.patrolDir *= -1;
      }
      e.fireTimer -= dt;
      if (e.fireTimer <= 0) {
        // Fire straight up along landing path
        fireBombDir(e.x, e.y - 6, 0, -ROUNDS[currentRound].bombSpeed);
        e.fireTimer = 1.2 + Math.random() * 1;
      }
    } else { // alien
      // Patrol back and forth
      e.x += e.vx * dt * 60;
      e.y += Math.sin(e.stateTimer * 1.5) * 0.3; // gentle bob

      // Reverse at patrol bounds
      if (Math.abs(e.x - e.originX) > e.patrolRange) {
        e.vx *= -1;
        e.patrolDir *= -1;
      }
      // Keep on screen
      if (e.x < 10) { e.x = 10; e.vx = Math.abs(e.vx); }
      if (e.x > worldWidth - 10) { e.x = worldWidth - 10; e.vx = -Math.abs(e.vx); }

      e.fireTimer -= dt;
      if (e.fireTimer <= 0) {
        fireBomb(e.x, e.y + 6);
        e.fireTimer = 1.5 + Math.random() * 2;
      }
    }
  }
}

function updateBombs(dt) {
  const cfg = ROUNDS[currentRound];

  for (let i = 0; i < MAX_BOMBS; i++) {
    const b = bombs[i];
    if (!b.active) continue;
    b.x += b.vx * dt * 60;
    b.y += b.vy * dt * 60;
    b.vy += 0.02 * dt * 60; // slight gravity on bombs
    b.life -= dt;

    if (b.life <= 0 || b.x < -20 || b.x > worldWidth + 20 || b.y < -20) {
      b.active = false;
      continue;
    }

    // Terrain collision → explode
    if (b.y >= getTerrainY(b.x)) {
      explodeBomb(b.x, b.y, cfg.blastRadius);
      b.active = false;
      continue;
    }

    // Hit player? Check distance
    const dToShip = dist(b.x, b.y, ship.x, ship.y);
    if (dToShip < SHIP_SIZE + 4) {
      explodeBomb(b.x, b.y, cfg.blastRadius);
      b.active = false;
      continue;
    }
  }
}

function explodeBomb(x, y, radius) {
  sfxBombExplode();
  triggerShake(4);
  // Hit by bomb = instant death
  const dToShip = dist(x, y, ship.x, ship.y);
  if (dToShip < radius && state === STATE.PLAYING) {
    crashShip();
  }

  // Visual explosion
  for (let i = 0; i < 20; i++) {
    const ang = Math.random() * Math.PI * 2;
    const spd = 0.5 + Math.random() * 2;
    spawnParticle(x, y,
      Math.cos(ang) * spd, Math.sin(ang) * spd,
      0.3 + Math.random() * 0.4,
      1.5 + Math.random() * 2,
      ['#ff6600', '#ff3300', '#ffaa00'][Math.floor(Math.random() * 3)],
      0);
  }

  // Blast radius ring (brief)
  spawnParticle(x, y, 0, 0, 0.15, radius * 0.3, 'rgba(255,100,0,0.3)', 1);
}

function drawEnemies() {
  for (let i = 0; i < MAX_ENEMIES; i++) {
    const e = enemies[i];
    if (!e.active) continue;

    if (e.state === 'telegraph') {
      // Green head peeking up
      const bob = Math.sin(e.stateTimer * 12) * 2;
      const rise = Math.min(e.stateTimer / 0.5, 1) * 8;
      ctx.fillStyle = '#44ff44';
      ctx.beginPath();
      ctx.arc(e.x, e.y - rise + bob, 5, 0, Math.PI * 2);
      ctx.fill();
      // Eyes
      ctx.fillStyle = '#000';
      ctx.fillRect(e.x - 2, e.y - rise + bob - 1, 1.5, 1.5);
      ctx.fillRect(e.x + 1, e.y - rise + bob - 1, 1.5, 1.5);
      continue;
    }

    if (e.state === 'dying') {
      ctx.globalAlpha = 1 - e.stateTimer / 0.3;
      ctx.fillStyle = '#ff4400';
      ctx.fillRect(e.x - 6, e.y - 6, 12, 12);
      ctx.globalAlpha = 1;
      continue;
    }

    // Active enemies
    if (e.type === 'turret') {
      // Base
      ctx.fillStyle = '#884444';
      ctx.fillRect(e.x - 8, e.y - 10, 16, 10);
      // Barrel - aim at player
      const aimAng = Math.atan2(ship.x - e.x, -(ship.y - e.y));
      ctx.save();
      ctx.translate(e.x, e.y - 10);
      ctx.rotate(aimAng);
      ctx.fillStyle = '#aa6666';
      ctx.fillRect(-2, -10, 4, 10);
      ctx.restore();
      // HP pips
      drawEnemyHP(e);
    } else if (e.type === 'padAlien') {
      // Pad alien — crawls across the pad, distinct red/orange color
      ctx.fillStyle = '#cc4422';
      ctx.beginPath();
      ctx.ellipse(e.x, e.y, 8, 6, 0, 0, Math.PI * 2);
      ctx.fill();
      // Antennae
      ctx.strokeStyle = '#ff6644';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(e.x - 3, e.y - 5);
      ctx.lineTo(e.x - 5, e.y - 10);
      ctx.moveTo(e.x + 3, e.y - 5);
      ctx.lineTo(e.x + 5, e.y - 10);
      ctx.stroke();
      // Eyes
      ctx.fillStyle = '#ff0';
      ctx.fillRect(e.x - 3, e.y - 2, 2, 2);
      ctx.fillRect(e.x + 1, e.y - 2, 2, 2);
      drawEnemyHP(e);
    } else { // alien
      // Body
      ctx.fillStyle = '#66aa44';
      ctx.beginPath();
      ctx.ellipse(e.x, e.y, 10, 7, 0, 0, Math.PI * 2);
      ctx.fill();
      // Dome
      ctx.fillStyle = '#88cc66';
      ctx.beginPath();
      ctx.ellipse(e.x, e.y - 5, 6, 5, 0, Math.PI, 0);
      ctx.fill();
      // Eyes
      ctx.fillStyle = '#ff0';
      ctx.fillRect(e.x - 3, e.y - 2, 2, 2);
      ctx.fillRect(e.x + 1, e.y - 2, 2, 2);
      // HP pips
      drawEnemyHP(e);
    }
  }
}

function drawEnemyHP(e) {
  if (e.hp >= e.maxHp) return;
  const barW = 14;
  const barH = 2;
  const bx = e.x - barW / 2;
  const by = e.type === 'turret' ? e.y - 16 : e.y - 14;
  ctx.fillStyle = '#400';
  ctx.fillRect(bx, by, barW, barH);
  ctx.fillStyle = '#f44';
  ctx.fillRect(bx, by, barW * (e.hp / e.maxHp), barH);
}

function drawBombs() {
  for (let i = 0; i < MAX_BOMBS; i++) {
    const b = bombs[i];
    if (!b.active) continue;
    // Bomb body
    ctx.fillStyle = '#ff4400';
    ctx.beginPath();
    ctx.arc(b.x, b.y, 3, 0, Math.PI * 2);
    ctx.fill();
    // Glow
    ctx.globalAlpha = 0.3;
    ctx.fillStyle = '#ff8800';
    ctx.beginPath();
    ctx.arc(b.x, b.y, 5, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;
    // Trail
    ctx.fillStyle = '#ff6600';
    ctx.globalAlpha = 0.4;
    ctx.fillRect(b.x - b.vx * 0.15 - 1, b.y - b.vy * 0.15 - 1, 2, 2);
    ctx.globalAlpha = 1;
  }
}

function clearEnemies() {
  for (let i = 0; i < MAX_ENEMIES; i++) enemies[i].active = false;
  for (let i = 0; i < MAX_BOMBS; i++) bombs[i].active = false;
  enemySpawnTimer = 3; // delay before first enemy
  enemiesSpawned = 0;
}

// ── Game Flow ──
function startGame() {
  currentRound = 0;
  score = 0;
  enemiesKilled = 0;
  lives = 3;
  startRound();
}

function startRound() {
  const cfg = ROUNDS[currentRound];
  // Set world width for this round
  worldWidth = cfg.worldWidth || W;
  terrainX = []; terrainY = [];
  generateTerrain(cfg);
  resetShip();
  clearParticles();
  clearBullets();
  clearEnemies();
  roundKills = 0;
  // Reset astronaut animation
  astro = { phase:0, timer:0, x:0, y:0, targetX:0, legFrame:0, flagX:0, flagY:0, flagHeight:0 };
  // Snap camera to ship position (no smooth lag on round start)
  cameraX = clamp(ship.x - W / 2, 0, Math.max(0, worldWidth - W));
  // Regenerate stars for new world size
  generateStars();
  // Spawn pad alien if configured
  if (cfg.padAlien) {
    spawnPadAlien();
  }
  // Spawn required-kill guards near the pad so player doesn't have to hunt
  if (cfg.requiredKills > 0) {
    spawnPadGuards(cfg.requiredKills);
  }
  state = STATE.ROUND_INTRO;
  stateTimer = 0;
}

function nextRound() {
  currentRound++;
  if (currentRound >= ROUNDS.length) {
    state = STATE.WIN;
    stateTimer = 0;
    stopMusic();
    resetWinFireworks();
    sfxVictory();
    if (score > hiScore) {
      hiScore = score;
      localStorage.setItem('spaceLanderHi', String(hiScore));
    }
  } else {
    startRound();
  }
}

function crashShip() {
  spawnExplosion(ship.x, ship.y);
  lives--;
  if (lives <= 0) {
    state = STATE.CRASHED;  // game over
    stateTimer = 0;
    sfxCrash();
    stopMusic();
    resetEmbers();
    if (score > hiScore) {
      hiScore = score;
      localStorage.setItem('spaceLanderHi', String(hiScore));
    }
  } else {
    state = STATE.CRASHED;
    stateTimer = 0;
    sfxCrash();
  }
}

function restartRound() {
  if (lives <= 0) {
    // Game over — back to title
    state = STATE.TITLE;
    return;
  }
  startRound();
}

// ── Physics Update ──
function updatePlaying(dt) {
  const cfg = ROUNDS[currentRound];

  // ── Side Thrusters ──
  // Left thruster: fires down-left at 45°, pushes ship up-right
  // Right thruster: fires down-right at 45°, pushes ship up-left
  // Both together: horizontal cancels, net upward thrust
  const thrustPower = 0.09;
  const THRUSTER_ANGLE = Math.PI / 4; // 45 degrees
  const leftOn = (keys['ArrowLeft'] || touchLeft) && ship.fuel > 0;
  const rightOn = (keys['ArrowRight'] || touchRight) && ship.fuel > 0;
  const upOn = (keys['ArrowUp'] || touchThrust) && ship.fuel > 0;

  ship.thrustL = leftOn || upOn;
  ship.thrustR = rightOn || upOn;

  if (ship.thrustL) {
    // Left thruster pushes up and to the right
    ship.vx += Math.sin(THRUSTER_ANGLE) * thrustPower * dt * 60;   // rightward
    ship.vy += -Math.cos(THRUSTER_ANGLE) * thrustPower * dt * 60;  // upward
    ship.fuel -= dt * 60 * 0.5;
    spawnThrusterParticle(-1); // left nozzle
  }
  if (ship.thrustR) {
    // Right thruster pushes up and to the left
    ship.vx += -Math.sin(THRUSTER_ANGLE) * thrustPower * dt * 60;  // leftward
    ship.vy += -Math.cos(THRUSTER_ANGLE) * thrustPower * dt * 60;  // upward
    ship.fuel -= dt * 60 * 0.5;
    spawnThrusterParticle(1);  // right nozzle
  }

  // Thrust SFX (throttled)
  if (ship.thrustL || ship.thrustR) {
    if (Date.now() - lastThrustSfx > 80) { sfxThrust(); lastThrustSfx = Date.now(); }
  }
  ship.fuel = Math.max(0, ship.fuel);

  // Gravity
  ship.vy += cfg.gravity * dt * 60;

  // Horizontal drag — gentle dampening to reduce drift
  ship.vx *= 0.997;

  // Apply velocity
  ship.x += ship.vx * dt * 60;
  ship.y += ship.vy * dt * 60;

  // Wall collision at world edges (red crash-walls)
  if (ship.x - SHIP_SIZE < WORLD_EDGE_MARGIN || ship.x + SHIP_SIZE > worldWidth - WORLD_EDGE_MARGIN) {
    crashShip();
    return;
  }

  // Clamp top
  if (ship.y < 10) { ship.y = 10; ship.vy = Math.max(0, ship.vy); }

  // ── Collision Detection ──
  const shipBottom = ship.y + SHIP_SIZE;
  const terrainAtShip = getTerrainY(ship.x);

  if (shipBottom >= terrainAtShip) {
    // Check if on landing pad
    const onPad = ship.x >= padLeft && ship.x <= padRight;
    const landingOk = Math.abs(ship.vy) <= MAX_LAND_VY &&
                      Math.abs(ship.vx) <= MAX_LAND_VX;
    // Check required kills
    const killsOk = roundKills >= cfg.requiredKills;
    // Check no pad alien blocking
    let padBlocked = false;
    for (let i = 0; i < MAX_ENEMIES; i++) {
      const e = enemies[i];
      if (e.active && e.type === 'padAlien' && e.state === 'active') {
        padBlocked = true;
        break;
      }
    }

    if (onPad && landingOk && killsOk && !padBlocked) {
      // Successful landing
      ship.y = terrainAtShip - SHIP_SIZE;
      ship.vx = 0; ship.vy = 0;
      // Score: fuel bonus + lives bonus + round multiplier
      roundScore = Math.floor(ship.fuel) * 2 + lives * 50 + (currentRound + 1) * 50;
      score += roundScore;
      // Gain a life
      lives = Math.min(lives + 1, MAX_LIVES);
      state = STATE.LANDED;
      stateTimer = 0;
      sfxLanding();
      // Start astronaut flag-planting animation
      astro.phase = 1;
      astro.timer = 0;
    } else if (onPad && landingOk && (!killsOk || padBlocked)) {
      // Bounced off — can't land yet, push back up gently
      ship.y = terrainAtShip - SHIP_SIZE - 2;
      ship.vy = -1;
    } else {
      // Crash!
      crashShip();
    }
  }

  // Held fire (Space key or touch fire button)
  if (keys['Space'] || touchFire) {
    fireBullet();
  }

  updateBullets(dt);
  updateEnemies(dt);
  updateBombs(dt);
  updateParticles(dt);
}

function spawnThrusterParticle(side) {
  // side: -1 = left nozzle, 1 = right nozzle
  if (Math.random() > 0.6) return;
  // Nozzle positions at bottom corners of the ship
  const nozzleX = ship.x + side * SHIP_SIZE * 0.7;
  const nozzleY = ship.y + SHIP_SIZE * 0.7;
  // Exhaust fires at 45° outward-downward
  const exVx = side * (1.5 + Math.random()) + (Math.random() - 0.5) * 0.4;
  const exVy = (1.5 + Math.random()) + (Math.random() - 0.5) * 0.4;
  spawnParticle(
    nozzleX + (Math.random() - 0.5) * 3,
    nozzleY + (Math.random() - 0.5) * 2,
    exVx, exVy,
    0.25 + Math.random() * 0.2,
    1.5 + Math.random() * 1.5,
    Math.random() < 0.5 ? '#ff6622' : '#ffaa22',
    0
  );
}

function spawnExplosion(x, y) {
  triggerShake(8);
  for (let i = 0; i < 40; i++) {
    const ang = Math.random() * Math.PI * 2;
    const spd = 1 + Math.random() * 3;
    spawnParticle(
      x + (Math.random() - 0.5) * 10,
      y + (Math.random() - 0.5) * 10,
      Math.cos(ang) * spd,
      Math.sin(ang) * spd,
      0.5 + Math.random() * 0.8,
      1.5 + Math.random() * 2,
      ['#ff4400', '#ff8800', '#ffcc00', '#ffffff'][Math.floor(Math.random() * 4)],
      0
    );
  }
}

// ── Drawing ──
function drawStars() {
  for (let i = 0; i < stars.length; i++) {
    const s = stars[i];
    ctx.globalAlpha = s.bright * (0.7 + Math.sin(Date.now() * 0.001 + i) * 0.3);
    ctx.fillStyle = '#fff';
    ctx.fillRect(s.x - s.size / 2, s.y - s.size / 2, s.size, s.size);
  }
  ctx.globalAlpha = 1;
}

function drawTerrain() {
  // Visible range (for optimized drawing)
  const visLeft = cameraX - 20;
  const visRight = cameraX + W + 20;
  const segW = worldWidth / terrainPointCount;

  // Wall borders at world edges (red crash-walls)
  ctx.strokeStyle = '#ff4444';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(1, 0); ctx.lineTo(1, WORLD_BOTTOM);
  ctx.moveTo(worldWidth - 1, 0); ctx.lineTo(worldWidth - 1, WORLD_BOTTOM);
  ctx.stroke();
  // Subtle glow
  ctx.strokeStyle = 'rgba(255,68,68,0.2)';
  ctx.lineWidth = 4;
  ctx.beginPath();
  ctx.moveTo(2, 0); ctx.lineTo(2, WORLD_BOTTOM);
  ctx.moveTo(worldWidth - 2, 0); ctx.lineTo(worldWidth - 2, WORLD_BOTTOM);
  ctx.stroke();

  // Fill terrain (only visible segments for performance)
  const startI = Math.max(0, Math.floor(visLeft / segW) - 1);
  const endI = Math.min(terrainX.length - 1, Math.ceil(visRight / segW) + 1);

  ctx.beginPath();
  ctx.moveTo(terrainX[startI], H);
  for (let i = startI; i <= endI; i++) {
    ctx.lineTo(terrainX[i], terrainY[i]);
  }
  ctx.lineTo(terrainX[endI], H);
  ctx.closePath();

  // Gradient fill (per-round planet colours)
  const tc = ROUNDS[currentRound].terrainColors;
  const grad = ctx.createLinearGradient(0, WORLD_BOTTOM - 200, 0, WORLD_BOTTOM);
  grad.addColorStop(0, tc.top);
  grad.addColorStop(0.5, tc.mid);
  grad.addColorStop(1, tc.bot);
  ctx.fillStyle = grad;
  ctx.fill();

  // Terrain outline (visible segments only)
  ctx.beginPath();
  for (let i = startI; i <= endI; i++) {
    if (i === startI) ctx.moveTo(terrainX[i], terrainY[i]);
    else ctx.lineTo(terrainX[i], terrainY[i]);
  }
  ctx.strokeStyle = tc.stroke;
  ctx.lineWidth = 2;
  ctx.stroke();

  // Landing pad
  ctx.fillStyle = '#00ff88';
  const padY = getTerrainY((padLeft + padRight) / 2);
  ctx.fillRect(padLeft, padY - 3, padRight - padLeft, 6);

  // Pad markers
  ctx.strokeStyle = '#00ff88';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(padLeft, padY - 12); ctx.lineTo(padLeft, padY);
  ctx.moveTo(padRight, padY - 12); ctx.lineTo(padRight, padY);
  ctx.stroke();

  // Pad light blink
  const blink = Math.sin(Date.now() * 0.005) > 0;
  if (blink) {
    ctx.fillStyle = '#00ff88';
    ctx.beginPath();
    ctx.arc(padLeft + 3, padY - 10, 2, 0, Math.PI * 2);
    ctx.arc(padRight - 3, padY - 10, 2, 0, Math.PI * 2);
    ctx.fill();
  }
}

function drawShip() {
  if (state === STATE.CRASHED) return;
  const S = SHIP_SIZE;

  ctx.save();
  ctx.translate(ship.x, ship.y);
  // No rotation — ship always upright

  // ── Landing legs (wide stance) ──
  ctx.strokeStyle = '#8899aa';
  ctx.lineWidth = 2;
  // Left leg
  ctx.beginPath();
  ctx.moveTo(-S * 0.5, S * 0.6);
  ctx.lineTo(-S * 1.1, S + 6);
  ctx.stroke();
  // Right leg
  ctx.beginPath();
  ctx.moveTo(S * 0.5, S * 0.6);
  ctx.lineTo(S * 1.1, S + 6);
  ctx.stroke();
  // Feet (wide pads)
  ctx.strokeStyle = '#aabbcc';
  ctx.lineWidth = 2.5;
  ctx.beginPath();
  ctx.moveTo(-S * 1.3, S + 6);
  ctx.lineTo(-S * 0.85, S + 6);
  ctx.moveTo(S * 0.85, S + 6);
  ctx.lineTo(S * 1.3, S + 6);
  ctx.stroke();

  // ── Main body (wide boxy lander) ──
  ctx.fillStyle = '#c0ccdd';
  ctx.strokeStyle = '#778899';
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.moveTo(-S * 0.9, S * 0.6);   // bottom-left
  ctx.lineTo(-S * 0.7, -S * 0.3);  // upper-left
  ctx.lineTo(-S * 0.3, -S * 0.6);  // top-left shoulder
  ctx.lineTo(S * 0.3, -S * 0.6);   // top-right shoulder
  ctx.lineTo(S * 0.7, -S * 0.3);   // upper-right
  ctx.lineTo(S * 0.9, S * 0.6);    // bottom-right
  ctx.closePath();
  ctx.fill();
  ctx.stroke();

  // ── Dome / cockpit window ──
  ctx.fillStyle = '#44aaff';
  ctx.strokeStyle = '#3388cc';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.arc(0, -S * 0.55, S * 0.35, Math.PI, 0);
  ctx.closePath();
  ctx.fill();
  ctx.stroke();

  // ── Side thruster nozzles ──
  // Left nozzle (angled outward)
  ctx.fillStyle = ship.thrustL ? '#ffaa44' : '#667788';
  ctx.strokeStyle = '#556677';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(-S * 0.75, S * 0.3);
  ctx.lineTo(-S * 1.05, S * 0.7);
  ctx.lineTo(-S * 0.8, S * 0.7);
  ctx.closePath();
  ctx.fill();
  ctx.stroke();

  // Right nozzle (angled outward)
  ctx.fillStyle = ship.thrustR ? '#ffaa44' : '#667788';
  ctx.beginPath();
  ctx.moveTo(S * 0.75, S * 0.3);
  ctx.lineTo(S * 1.05, S * 0.7);
  ctx.lineTo(S * 0.8, S * 0.7);
  ctx.closePath();
  ctx.fill();
  ctx.stroke();

  // ── Belly gun ──
  ctx.fillStyle = '#ff6644';
  ctx.fillRect(-2, S * 0.5, 4, S * 0.3);
  // Gun barrel tip
  ctx.fillStyle = '#ff4422';
  ctx.fillRect(-1.5, S * 0.75, 3, 3);

  // ── Panel detail lines ──
  ctx.strokeStyle = '#8899aa';
  ctx.lineWidth = 0.5;
  ctx.beginPath();
  ctx.moveTo(-S * 0.4, -S * 0.1);
  ctx.lineTo(S * 0.4, -S * 0.1);
  ctx.moveTo(-S * 0.5, S * 0.2);
  ctx.lineTo(S * 0.5, S * 0.2);
  ctx.stroke();

  ctx.restore();
}

// ── Astronaut Drawing & Animation ──
function drawAstronaut() {
  if (astro.phase === 0) return;
  const ax = astro.x;
  const ay = astro.y;

  // ── Flag (draw behind astronaut) ──
  if (astro.phase >= 3 && astro.flagHeight > 0) {
    const fx = astro.flagX;
    const fy = astro.flagY;
    const ph = astro.flagHeight;
    // Pole
    ctx.strokeStyle = '#cccccc';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(fx, fy);
    ctx.lineTo(fx, fy - ph);
    ctx.stroke();
    // Pennant (when pole tall enough)
    if (ph > 5) {
      const wave = Math.sin(Date.now() * 0.006) * 1;
      ctx.fillStyle = '#ff4444';
      ctx.beginPath();
      ctx.moveTo(fx + 1, fy - ph);
      ctx.lineTo(fx + 9 + wave, fy - ph + 2.5);
      ctx.lineTo(fx + 1, fy - ph + 5);
      ctx.closePath();
      ctx.fill();
    }
  }

  // ── Astronaut figure (~12px tall, Sensible Soccer style) ──
  // Head (white helmet, 4px diameter)
  ctx.fillStyle = '#ffffff';
  ctx.beginPath();
  ctx.arc(ax, ay - 10, 2.5, 0, Math.PI * 2);
  ctx.fill();
  // Visor (gold)
  ctx.fillStyle = '#ffcc44';
  ctx.fillRect(ax - 1.5, ay - 11, 3, 1.5);

  // Body (white suit)
  ctx.fillStyle = '#dddddd';
  ctx.fillRect(ax - 2, ay - 7.5, 4, 5);
  // Backpack
  ctx.fillStyle = '#999999';
  ctx.fillRect(ax + 2, ay - 7, 1.5, 3);

  // Legs
  ctx.strokeStyle = '#cccccc';
  ctx.lineWidth = 1.5;
  if (astro.phase === 2) {
    // Walking: animated legs
    const lc = Math.sin(astro.legFrame * 10);
    ctx.beginPath();
    ctx.moveTo(ax - 1, ay - 2.5);
    ctx.lineTo(ax - 1 + lc * 2.5, ay);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(ax + 1, ay - 2.5);
    ctx.lineTo(ax + 1 - lc * 2.5, ay);
    ctx.stroke();
  } else {
    // Standing
    ctx.beginPath();
    ctx.moveTo(ax - 1, ay - 2.5); ctx.lineTo(ax - 2, ay);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(ax + 1, ay - 2.5); ctx.lineTo(ax + 2, ay);
    ctx.stroke();
  }

  // Arms
  ctx.strokeStyle = '#cccccc';
  ctx.lineWidth = 1;
  if (astro.phase === 3) {
    // Planting: right arm reaches up
    const reach = clamp(astro.timer / 0.5, 0, 1);
    const armAng = -Math.PI * 0.3 - reach * Math.PI * 0.35;
    ctx.beginPath();
    ctx.moveTo(ax + 2, ay - 6);
    ctx.lineTo(ax + 2 + Math.cos(armAng) * 5, ay - 6 + Math.sin(armAng) * 5);
    ctx.stroke();
    // Left arm at side
    ctx.beginPath();
    ctx.moveTo(ax - 2, ay - 6); ctx.lineTo(ax - 4, ay - 3);
    ctx.stroke();
  } else if (astro.phase === 4) {
    // Done: arm pointing at flag
    ctx.beginPath();
    ctx.moveTo(ax + 2, ay - 6); ctx.lineTo(ax + 5, ay - 10);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(ax - 2, ay - 6); ctx.lineTo(ax - 4, ay - 3);
    ctx.stroke();
  } else {
    // Default: arms at sides
    ctx.beginPath();
    ctx.moveTo(ax - 2, ay - 6); ctx.lineTo(ax - 4, ay - 3);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(ax + 2, ay - 6); ctx.lineTo(ax + 4, ay - 3);
    ctx.stroke();
  }
}

function updateAstronaut(dt) {
  if (astro.phase === 0) return;
  astro.timer += dt;

  if (astro.phase === 1) {
    // Emerge: slide from ship centre down to terrain
    const progress = clamp(astro.timer / 0.8, 0, 1);
    const groundY = getTerrainY(ship.x);
    astro.x = ship.x;
    astro.y = lerp(ship.y, groundY, progress);
    if (astro.timer >= 0.8) {
      astro.phase = 2;
      astro.timer = 0;
      astro.targetX = ship.x + 35;
    }
  } else if (astro.phase === 2) {
    // Walk to target
    const progress = clamp(astro.timer / 1.2, 0, 1);
    astro.x = lerp(ship.x, astro.targetX, progress);
    astro.y = getTerrainY(astro.x);
    astro.legFrame = astro.timer;
    if (astro.timer >= 1.2) {
      astro.phase = 3;
      astro.timer = 0;
      astro.flagX = astro.x + 4;
      astro.flagY = getTerrainY(astro.flagX);
      astro.flagHeight = 0;
    }
  } else if (astro.phase === 3) {
    // Plant flag: pole grows upward
    const progress = clamp(astro.timer / 1.0, 0, 1);
    astro.flagHeight = progress * 16;
    if (astro.timer >= 1.0) {
      astro.phase = 4;
      astro.timer = 0;
      astro.flagHeight = 16;
    }
  }
  // Phase 4: done, static pose
}

// ── Win Screen Fireworks (screen-space, separate from game particles) ──
const WIN_FIREWORKS_MAX = 100;
let winFireworks = [];
let winFireworkTimer = 0;
let winFireworkBurstTimer = 0;
// Ember particles for game over
const EMBERS_MAX = 40;
let embers = [];

function resetWinFireworks() {
  winFireworks = [];
  winFireworkTimer = 0;
  winFireworkBurstTimer = 0;
}

function resetEmbers() {
  embers = [];
}

function spawnWinFireworkBurst(bx, by) {
  const hue = Math.random() * 360;
  const count = 18 + Math.floor(Math.random() * 14);
  for (let i = 0; i < count; i++) {
    if (winFireworks.length >= WIN_FIREWORKS_MAX) break;
    const ang = (Math.PI * 2 / count) * i + (Math.random() - 0.5) * 0.3;
    const spd = 60 + Math.random() * 100;
    const hueOff = (Math.random() - 0.5) * 40;
    winFireworks.push({
      x: bx, y: by,
      vx: Math.cos(ang) * spd,
      vy: Math.sin(ang) * spd,
      life: 0.8 + Math.random() * 0.6,
      maxLife: 0.8 + Math.random() * 0.6,
      r: 1.5 + Math.random() * 1.5,
      hue: (hue + hueOff + 360) % 360,
      trail: []
    });
  }
}

function updateWinFireworks(dt) {
  winFireworkBurstTimer -= dt;
  if (winFireworkBurstTimer <= 0) {
    winFireworkBurstTimer = 0.4 + Math.random() * 0.6;
    const bx = 60 + Math.random() * (W - 120);
    const by = 80 + Math.random() * (H * 0.45);
    spawnWinFireworkBurst(bx, by);
    sfxFirework();
  }
  for (let i = winFireworks.length - 1; i >= 0; i--) {
    const p = winFireworks[i];
    p.x += p.vx * dt;
    p.y += p.vy * dt;
    p.vy += 50 * dt; // gentle gravity
    p.vx *= 0.98;
    p.life -= dt;
    // Store trail positions
    if (p.trail.length < 5) p.trail.push({ x: p.x, y: p.y });
    else { p.trail.shift(); p.trail.push({ x: p.x, y: p.y }); }
    if (p.life <= 0) {
      winFireworks.splice(i, 1);
    }
  }
}

function drawWinFireworks() {
  for (let i = 0; i < winFireworks.length; i++) {
    const p = winFireworks[i];
    const alpha = clamp(p.life / p.maxLife, 0, 1);
    // Trail
    for (let t = 0; t < p.trail.length; t++) {
      const ta = alpha * (t / p.trail.length) * 0.4;
      ctx.fillStyle = hsl(p.hue, 90, 65, ta);
      ctx.beginPath();
      ctx.arc(p.trail[t].x, p.trail[t].y, p.r * 0.5, 0, Math.PI * 2);
      ctx.fill();
    }
    // Main spark
    ctx.fillStyle = hsl(p.hue, 90, 70, alpha);
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
    ctx.fill();
    // Bright core
    ctx.fillStyle = hsl(p.hue, 40, 95, alpha * 0.8);
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.r * 0.4, 0, Math.PI * 2);
    ctx.fill();
  }
}

// Embers for game over screen
function spawnEmber() {
  if (embers.length >= EMBERS_MAX) return;
  embers.push({
    x: Math.random() * W,
    y: H + 5,
    vx: (Math.random() - 0.5) * 15,
    vy: -(20 + Math.random() * 40),
    life: 2.5 + Math.random() * 2,
    maxLife: 2.5 + Math.random() * 2,
    r: 1 + Math.random() * 2,
    hue: Math.random() < 0.5 ? 15 : 30 // red or orange
  });
}

function updateEmbers(dt) {
  for (let i = embers.length - 1; i >= 0; i--) {
    const e = embers[i];
    e.x += e.vx * dt;
    e.y += e.vy * dt;
    e.vx += (Math.random() - 0.5) * 10 * dt; // drift
    e.life -= dt;
    if (e.life <= 0) embers.splice(i, 1);
  }
}

function drawEmbers() {
  for (let i = 0; i < embers.length; i++) {
    const e = embers[i];
    const alpha = clamp(e.life / e.maxLife, 0, 1);
    ctx.fillStyle = hsl(e.hue, 90, 55, alpha * 0.7);
    ctx.beginPath();
    ctx.arc(e.x, e.y, e.r, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = hsl(e.hue, 50, 85, alpha * 0.5);
    ctx.beginPath();
    ctx.arc(e.x, e.y, e.r * 0.4, 0, Math.PI * 2);
    ctx.fill();
  }
}

function drawHUD() {
  const cfg = ROUNDS[currentRound];
  const panelY = WORLD_BOTTOM;

  // Cockpit panel background — metallic gradient
  const panelGrad = ctx.createLinearGradient(0, panelY, 0, H);
  panelGrad.addColorStop(0, '#2a2a3e');
  panelGrad.addColorStop(0.15, '#1a1a2e');
  panelGrad.addColorStop(0.85, '#141428');
  panelGrad.addColorStop(1, '#0e0e1e');
  ctx.fillStyle = panelGrad;
  ctx.fillRect(0, panelY, W, HUD_HEIGHT);

  // Top bezel — bright edge
  ctx.strokeStyle = '#556';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(0, panelY); ctx.lineTo(W, panelY);
  ctx.stroke();
  ctx.strokeStyle = '#223';
  ctx.beginPath();
  ctx.moveTo(0, panelY + 2); ctx.lineTo(W, panelY + 2);
  ctx.stroke();

  // Rivet dots along top edge
  ctx.fillStyle = '#445';
  for (let rx = 20; rx < W; rx += 40) {
    ctx.beginPath();
    ctx.arc(rx, panelY + 6, 1.5, 0, Math.PI * 2);
    ctx.fill();
  }

  // Vertical dividers for 3-column layout
  const div1x = 135, div2x = W - 85;
  ctx.strokeStyle = '#334';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(div1x, panelY + 10); ctx.lineTo(div1x, H - 8);
  ctx.moveTo(div2x, panelY + 10); ctx.lineTo(div2x, H - 8);
  ctx.stroke();

  // ── Left column: Fuel & Ammo ──
  const col1 = 15;
  const labelY = panelY + 20;

  // Round
  ctx.fillStyle = '#88aacc';
  ctx.font = '11px monospace';
  ctx.textAlign = 'left';
  ctx.fillText(`ROUND ${currentRound + 1}/${ROUNDS.length}`, col1, labelY);
  ctx.fillStyle = '#ffcc44';
  ctx.font = '9px monospace';
  ctx.fillText(`SCORE ${score}`, col1 + 60, labelY);

  // Fuel bar
  drawBar(col1, labelY + 10, 100, 10, ship.fuel / ship.maxFuel, '#00cc44', 'FUEL');

  // Ammo bar
  const ammoFrac = ship.maxAmmo > 0 ? ship.ammo / ship.maxAmmo : 0;
  drawBar(col1, labelY + 32, 100, 10, ammoFrac, '#ffaa00', 'AMMO');

  // Lives display
  ctx.fillStyle = '#88aacc';
  ctx.font = '9px monospace';
  ctx.fillText('LIVES', col1, labelY + 57);
  for (let li = 0; li < lives; li++) {
    ctx.fillStyle = '#44ff88';
    ctx.fillRect(col1 + 32 + li * 12, labelY + 50, 8, 8);
    ctx.strokeStyle = '#226644';
    ctx.lineWidth = 0.5;
    ctx.strokeRect(col1 + 32 + li * 12, labelY + 50, 8, 8);
  }

  // ── Center column: Flight data ──
  const col2 = W / 2;
  ctx.textAlign = 'center';
  ctx.fillStyle = '#88aacc';
  ctx.font = '10px monospace';

  ctx.fillText('V-SPD', col2 - 40, labelY + 12);
  ctx.fillStyle = Math.abs(ship.vy) > MAX_LAND_VY ? '#ff4444' : '#44ff88';
  ctx.font = '13px monospace';
  ctx.fillText(`${ship.vy.toFixed(1)}`, col2 - 40, labelY + 26);

  ctx.fillStyle = '#88aacc';
  ctx.font = '10px monospace';
  ctx.fillText('H-SPD', col2 + 40, labelY + 12);
  ctx.fillStyle = Math.abs(ship.vx) > MAX_LAND_VX ? '#ff4444' : '#44ff88';
  ctx.font = '13px monospace';
  ctx.fillText(`${ship.vx.toFixed(1)}`, col2 + 40, labelY + 26);

  // Thruster status
  ctx.fillStyle = '#88aacc';
  ctx.font = '10px monospace';
  ctx.fillText('THRUST', col2, labelY + 44);
  ctx.font = '13px monospace';
  const thrustStatus = (ship.thrustL && ship.thrustR) ? 'BOTH' :
                       ship.thrustL ? 'LEFT' :
                       ship.thrustR ? 'RIGHT' : '--';
  ctx.fillStyle = (ship.thrustL || ship.thrustR) ? '#ffaa44' : '#556677';
  ctx.fillText(thrustStatus, col2, labelY + 58);

  // Altitude
  const alt = Math.max(0, getTerrainY(ship.x) - (ship.y + SHIP_SIZE));
  ctx.fillStyle = '#88aacc';
  ctx.font = '10px monospace';
  ctx.fillText('ALT', col2 + 40, labelY + 44);
  ctx.fillStyle = '#44ff88';
  ctx.font = '13px monospace';
  ctx.fillText(`${Math.floor(alt)}`, col2 + 40, labelY + 58);

  // ── Right column: Radar ──
  const radarX = W - 70;
  const radarY = panelY + 15;
  const radarW = 55;
  const radarH = 55;
  drawRadar(radarX, radarY, radarW, radarH);

  // Mute indicator
  if (audioMuted) {
    ctx.fillStyle = '#666';
    ctx.font = '8px monospace';
    ctx.textAlign = 'right';
    ctx.fillText('MUTED [M]', W - 8, H - 5);
  }
}

function drawBar(x, y, w, h, frac, color, label) {
  frac = clamp(frac, 0, 1);
  ctx.fillStyle = '#88aacc';
  ctx.font = '9px monospace';
  ctx.textAlign = 'left';
  ctx.fillText(label, x, y);

  // Background
  ctx.fillStyle = '#112';
  ctx.fillRect(x, y + 3, w, h);

  // Fill
  ctx.fillStyle = color;
  ctx.fillRect(x, y + 3, w * frac, h);

  // Border
  ctx.strokeStyle = '#445';
  ctx.lineWidth = 1;
  ctx.strokeRect(x, y + 3, w, h);
}

function drawRadar(rx, ry, rw, rh) {
  // Background
  ctx.fillStyle = '#0a1a0a';
  ctx.fillRect(rx, ry, rw, rh);
  ctx.strokeStyle = '#1a3a1a';
  ctx.lineWidth = 1;
  ctx.strokeRect(rx, ry, rw, rh);

  // Grid lines
  ctx.strokeStyle = '#0f2f0f';
  ctx.beginPath();
  ctx.moveTo(rx + rw / 2, ry); ctx.lineTo(rx + rw / 2, ry + rh);
  ctx.moveTo(rx, ry + rh / 2); ctx.lineTo(rx + rw, ry + rh / 2);
  ctx.stroke();

  // Terrain mini (mapped to full worldWidth)
  ctx.strokeStyle = '#2a5a2a';
  ctx.lineWidth = 1;
  ctx.beginPath();
  // Skip more points for wider worlds to keep radar clean
  const skip = Math.max(3, Math.floor(terrainX.length / 120));
  for (let i = 0; i < terrainX.length; i += skip) {
    const mx = rx + (terrainX[i] / worldWidth) * rw;
    const my = ry + (terrainY[i] / WORLD_BOTTOM) * rh;
    if (i === 0) ctx.moveTo(mx, my);
    else ctx.lineTo(mx, my);
  }
  ctx.stroke();

  // Landing pad
  const padMX = rx + ((padLeft + padRight) / 2 / worldWidth) * rw;
  const padMY = ry + (getTerrainY((padLeft + padRight) / 2) / WORLD_BOTTOM) * rh;
  ctx.fillStyle = '#00ff88';
  ctx.fillRect(padMX - 2, padMY - 1, 4, 2);

  // Viewport indicator (shows current camera view)
  const vpLeft = rx + (cameraX / worldWidth) * rw;
  const vpWidth = Math.max(2, (W / worldWidth) * rw);
  ctx.strokeStyle = 'rgba(255,255,255,0.25)';
  ctx.lineWidth = 0.5;
  ctx.strokeRect(vpLeft, ry, vpWidth, rh);

  // Enemy dots
  for (let i = 0; i < MAX_ENEMIES; i++) {
    const e = enemies[i];
    if (!e.active || e.state === 'dying') continue;
    const emx = rx + (e.x / worldWidth) * rw;
    const emy = ry + (e.y / WORLD_BOTTOM) * rh;
    ctx.fillStyle = e.state === 'telegraph' ? '#44ff44' : '#ff4444';
    ctx.fillRect(emx - 1, emy - 1, 2, 2);
  }

  // Bomb dots
  for (let i = 0; i < MAX_BOMBS; i++) {
    const b = bombs[i];
    if (!b.active) continue;
    const bmx = rx + (b.x / worldWidth) * rw;
    const bmy = ry + (b.y / WORLD_BOTTOM) * rh;
    ctx.fillStyle = '#ff8800';
    ctx.fillRect(bmx, bmy, 1, 1);
  }

  // Ship dot
  const sx = rx + (ship.x / worldWidth) * rw;
  const sy = ry + (ship.y / WORLD_BOTTOM) * rh;
  ctx.fillStyle = '#ffffff';
  ctx.fillRect(sx - 1, sy - 1, 3, 3);

  // Label
  ctx.fillStyle = '#2a5a2a';
  ctx.font = '7px monospace';
  ctx.textAlign = 'center';
  ctx.fillText('RADAR', rx + rw / 2, ry + rh + 9);
}

function drawOverlay() {
  ctx.textAlign = 'center';

  if (state === STATE.TITLE) {
    // Darken
    ctx.fillStyle = 'rgba(0,0,0,0.7)';
    ctx.fillRect(0, 0, W, H);

    ctx.fillStyle = '#44ccff';
    ctx.font = 'bold 32px monospace';
    ctx.fillText('SPACE LANDER', W / 2, H * 0.25);

    ctx.fillStyle = '#88aacc';
    ctx.font = '12px monospace';
    if (isMobile) {
      ctx.fillText('Tap left side: Left booster', W / 2, H * 0.38);
      ctx.fillText('Tap right side: Right booster', W / 2, H * 0.42);
      ctx.fillText('Tap bottom panel: Fire weapons', W / 2, H * 0.46);
    } else {
      ctx.fillText('Left/Right: Side thrusters', W / 2, H * 0.38);
      ctx.fillText('Both or Up: Boost upward', W / 2, H * 0.42);
      ctx.fillText('Space: Fire weapons downward', W / 2, H * 0.46);
    }
    ctx.fillText('Find and land on the green pad!', W / 2, H * 0.50);
    ctx.fillText('Use the radar to navigate', W / 2, H * 0.54);
    if (!isMobile) ctx.fillText('M: Mute/Unmute', W / 2, H * 0.58);

    if (hiScore > 0) {
      ctx.fillStyle = '#ffcc44';
      ctx.font = '11px monospace';
      ctx.fillText(`High Score: ${hiScore}`, W / 2, H * 0.63);
    }

    ctx.fillStyle = '#ffcc44';
    ctx.font = '14px monospace';
    const blink = Math.sin(Date.now() * 0.004) > 0;
    if (blink) ctx.fillText(isMobile ? 'TAP TO START' : 'PRESS ENTER TO START', W / 2, H * 0.70);
  }

  if (state === STATE.ROUND_INTRO) {
    ctx.fillStyle = 'rgba(0,0,0,0.6)';
    ctx.fillRect(0, 0, W, WORLD_BOTTOM);

    const cfg = ROUNDS[currentRound];
    const tc = cfg.terrainColors;

    // Round number
    ctx.textAlign = 'center';
    ctx.fillStyle = '#44ccff';
    ctx.font = 'bold 28px monospace';
    ctx.fillText(`ROUND ${currentRound + 1}`, W / 2, WORLD_BOTTOM * 0.22);

    // Planet name (in terrain colour for flavour)
    ctx.fillStyle = tc.stroke;
    ctx.font = 'bold 16px monospace';
    ctx.fillText(cfg.planetName, W / 2, WORLD_BOTTOM * 0.30);

    // Planet description
    ctx.fillStyle = '#88aacc';
    ctx.font = '10px monospace';
    ctx.fillText(cfg.planetDesc, W / 2, WORLD_BOTTOM * 0.37);

    // Stats
    ctx.fillStyle = '#88aacc';
    ctx.font = '11px monospace';
    ctx.fillText(`Fuel: ${cfg.fuel}  |  Ammo: ${cfg.ammo}  |  Lives: ${lives}`, W / 2, WORLD_BOTTOM * 0.46);

    // Enemy warning
    if (cfg.enemyRate > 0 || cfg.padAlien) {
      ctx.fillStyle = '#ff8866';
      ctx.font = '10px monospace';
      let warning = 'Enemies active!';
      if (cfg.requiredKills > 0) warning += ` Kill ${cfg.requiredKills} to land.`;
      if (cfg.padAlien) warning = 'Alien on pad! Clear it to land.';
      if (cfg.padAlien && cfg.requiredKills > 0) warning = `Clear pad + kill ${cfg.requiredKills} to land!`;
      ctx.fillText(warning, W / 2, WORLD_BOTTOM * 0.53);
    }

    // Pad zone hint
    if (cfg.padZone === 'anywhere') {
      ctx.fillStyle = '#667799';
      ctx.font = '9px monospace';
      ctx.fillText('Landing pad hidden — use radar to find it', W / 2, WORLD_BOTTOM * 0.59);
    }

    ctx.fillStyle = '#ffcc44';
    ctx.font = '12px monospace';
    const blink = Math.sin(Date.now() * 0.004) > 0;
    if (blink) ctx.fillText(isMobile ? 'TAP TO CONTINUE' : 'PRESS ENTER', W / 2, WORLD_BOTTOM * 0.70);
  }

  if (state === STATE.LANDED) {
    // Wait for astronaut animation to finish before showing text
    if (astro.phase >= 4) {
      const fadeT = clamp((stateTimer - 3.0) / 0.5, 0, 1); // fade in after ~3s
      ctx.globalAlpha = fadeT;
      ctx.fillStyle = '#00ff88';
      ctx.font = 'bold 24px monospace';
      ctx.fillText('LANDED!', W / 2, WORLD_BOTTOM * 0.35);

      ctx.fillStyle = '#88aacc';
      ctx.font = '11px monospace';
      ctx.fillText(`Round score: +${roundScore}`, W / 2, WORLD_BOTTOM * 0.44);
      ctx.fillText(`Total: ${score}`, W / 2, WORLD_BOTTOM * 0.50);

      ctx.fillStyle = '#ffcc44';
      ctx.font = '12px monospace';
      const blink = Math.sin(Date.now() * 0.004) > 0;
      if (fadeT >= 1 && blink) ctx.fillText(isMobile ? 'TAP TO CONTINUE' : (currentRound < ROUNDS.length - 1 ? 'PRESS ENTER FOR NEXT ROUND' : 'PRESS ENTER'), W / 2, WORLD_BOTTOM * 0.58);
      ctx.globalAlpha = 1;
    }
  }

  if (state === STATE.CRASHED) {
    if (lives > 0) {
      // Still have lives — show crash + remaining
      ctx.fillStyle = '#ff4444';
      ctx.font = 'bold 24px monospace';
      ctx.fillText('CRASHED!', W / 2, WORLD_BOTTOM * 0.30);

      ctx.fillStyle = '#ff8866';
      ctx.font = '11px monospace';
      ctx.fillText(`Lives remaining: ${lives}`, W / 2, WORLD_BOTTOM * 0.40);

      ctx.fillStyle = '#ffcc44';
      ctx.font = '12px monospace';
      const blink = Math.sin(Date.now() * 0.004) > 0;
      if (blink) ctx.fillText(isMobile ? 'TAP TO RETRY' : 'PRESS ENTER TO RETRY', W / 2, WORLD_BOTTOM * 0.55);
    } else {
      // Game over — full screen overlay with ember particles and fade-in stats
      ctx.fillStyle = 'rgba(0,0,0,0.80)';
      ctx.fillRect(0, 0, W, H);

      // Draw embers behind text
      drawEmbers();

      // Pulsing red glow behind GAME OVER
      const glowPulse = 0.3 + Math.sin(stateTimer * 3) * 0.15;
      ctx.save();
      ctx.shadowColor = '#ff2222';
      ctx.shadowBlur = 25 + Math.sin(stateTimer * 2.5) * 12;
      ctx.fillStyle = `rgba(255, 68, 68, ${glowPulse})`;
      ctx.font = 'bold 28px monospace';
      ctx.fillText('GAME OVER', W / 2, H * 0.18);
      ctx.shadowBlur = 0;
      ctx.restore();
      // Solid text on top
      ctx.fillStyle = '#ff4444';
      ctx.font = 'bold 28px monospace';
      ctx.fillText('GAME OVER', W / 2, H * 0.18);

      // Sequential fade-in stats (each 0.4s apart, starting at 0.8s)
      const go1 = clamp((stateTimer - 0.8) / 0.4, 0, 1);
      const go2 = clamp((stateTimer - 1.2) / 0.4, 0, 1);
      const go3 = clamp((stateTimer - 1.6) / 0.4, 0, 1);
      const go4 = clamp((stateTimer - 2.0) / 0.4, 0, 1);
      const go5 = clamp((stateTimer - 2.4) / 0.4, 0, 1);

      if (go1 > 0) {
        ctx.globalAlpha = go1;
        ctx.fillStyle = '#88aacc';
        ctx.font = '13px monospace';
        ctx.fillText('Well played, pilot.', W / 2, H * 0.26);
      }
      if (go2 > 0) {
        ctx.globalAlpha = go2;
        ctx.fillStyle = '#44ff88';
        ctx.font = '12px monospace';
        const planetName = ROUNDS[Math.min(currentRound, ROUNDS.length - 1)].planetName;
        ctx.fillText(`Reached: ${planetName} (Round ${currentRound + 1}/${ROUNDS.length})`, W / 2, H * 0.33);
      }
      if (go3 > 0) {
        ctx.globalAlpha = go3;
        ctx.fillStyle = '#44ff88';
        ctx.font = '12px monospace';
        ctx.fillText(`Score: ${score}`, W / 2, H * 0.39);
        ctx.fillText(`Enemies destroyed: ${enemiesKilled}`, W / 2, H * 0.44);
      }
      if (go4 > 0) {
        ctx.globalAlpha = go4;
        if (score >= hiScore && score > 0) {
          ctx.fillStyle = '#ffcc44';
          ctx.font = 'bold 12px monospace';
          ctx.fillText('NEW HIGH SCORE!', W / 2, H * 0.50);
        } else {
          ctx.fillStyle = '#88aacc';
          ctx.font = '11px monospace';
          ctx.fillText(`Best: ${hiScore}`, W / 2, H * 0.50);
        }
      }
      if (go5 > 0) {
        ctx.globalAlpha = go5;
        // Tips
        ctx.fillStyle = '#667799';
        ctx.font = '10px monospace';
        ctx.fillText('--- TIPS ---', W / 2, H * 0.58);
        ctx.fillStyle = '#8899bb';
        ctx.font = '9px monospace';
        const tipSeed = (score * 7 + currentRound * 13) % TIPS.length;
        for (let ti = 0; ti < 3; ti++) {
          const tip = TIPS[(tipSeed + ti) % TIPS.length];
          ctx.fillText(tip, W / 2, H * 0.63 + ti * 0.05 * H);
        }
      }
      ctx.globalAlpha = 1;

      // Delayed prompt (2.5s)
      if (stateTimer > 2.5) {
        ctx.fillStyle = '#ffcc44';
        ctx.font = '12px monospace';
        const blink = Math.sin(Date.now() * 0.004) > 0;
        if (blink) ctx.fillText(isMobile ? 'TAP TO CONTINUE' : 'PRESS ENTER', W / 2, H * 0.85);
      }
    }
  }

  if (state === STATE.WIN) {
    ctx.fillStyle = 'rgba(0,0,0,0.75)';
    ctx.fillRect(0, 0, W, H);

    // Fireworks behind text
    drawWinFireworks();

    // Pulsing / bouncing title
    const bounce = Math.sin(stateTimer * 3) * 4;
    const pulse = 1 + Math.sin(stateTimer * 5) * 0.05;
    ctx.save();
    ctx.translate(W / 2, H * 0.22 + bounce);
    ctx.scale(pulse, pulse);
    // Title glow
    ctx.shadowColor = '#ffcc44';
    ctx.shadowBlur = 20 + Math.sin(stateTimer * 4) * 10;
    ctx.fillStyle = '#ffcc44';
    ctx.font = 'bold 26px monospace';
    ctx.textAlign = 'center';
    ctx.fillText('MISSION COMPLETE!', 0, 0);
    ctx.shadowBlur = 0;
    ctx.restore();

    // Sequential fade-in stats (each appears 0.5s after the last)
    ctx.textAlign = 'center';
    const line1 = clamp((stateTimer - 1.0) / 0.5, 0, 1);
    const line2 = clamp((stateTimer - 1.5) / 0.5, 0, 1);
    const line3 = clamp((stateTimer - 2.0) / 0.5, 0, 1);
    const line4 = clamp((stateTimer - 2.5) / 0.5, 0, 1);

    if (line1 > 0) {
      ctx.globalAlpha = line1;
      ctx.fillStyle = '#88aacc';
      ctx.font = '13px monospace';
      ctx.fillText('All 10 planets conquered!', W / 2, H * 0.33);
    }
    if (line2 > 0) {
      ctx.globalAlpha = line2;
      ctx.fillStyle = '#44ff88';
      ctx.font = '14px monospace';
      ctx.fillText(`Final Score: ${score}`, W / 2, H * 0.40);
    }
    if (line3 > 0) {
      ctx.globalAlpha = line3;
      ctx.fillStyle = '#88aacc';
      ctx.font = '11px monospace';
      ctx.fillText(`Enemies destroyed: ${enemiesKilled}`, W / 2, H * 0.46);
    }
    if (line4 > 0) {
      ctx.globalAlpha = line4;
      if (score >= hiScore && score > 0) {
        // Rainbow shimmer on high score
        const rainbowHue = (Date.now() * 0.2) % 360;
        ctx.fillStyle = hsl(rainbowHue, 90, 65);
        ctx.font = 'bold 14px monospace';
        ctx.shadowColor = hsl(rainbowHue, 90, 75);
        ctx.shadowBlur = 12;
        ctx.fillText('★ NEW HIGH SCORE! ★', W / 2, H * 0.53);
        ctx.shadowBlur = 0;
      } else {
        ctx.fillStyle = '#88aacc';
        ctx.font = '11px monospace';
        ctx.fillText(`Best: ${hiScore}`, W / 2, H * 0.53);
      }
    }
    ctx.globalAlpha = 1;

    // Prompt (delayed until 3.5s)
    if (stateTimer > 3.5) {
      ctx.fillStyle = '#ffcc44';
      ctx.font = '12px monospace';
      const blink = Math.sin(Date.now() * 0.004) > 0;
      if (blink) ctx.fillText(isMobile ? 'TAP TO CONTINUE' : 'PRESS ENTER', W / 2, H * 0.62);
    }
  }
}

// ── Audio System ──
let audioCtx = null;
let masterGain = null;
let musicGain = null;
let sfxGain = null;
let audioMuted = false;
let musicPlaying = false;

function initAudio() {
  if (audioCtx) return;
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  masterGain = audioCtx.createGain();
  masterGain.gain.value = 0.35;
  masterGain.connect(audioCtx.destination);

  musicGain = audioCtx.createGain();
  musicGain.gain.value = 0.15;
  musicGain.connect(masterGain);

  sfxGain = audioCtx.createGain();
  sfxGain.gain.value = 0.5;
  sfxGain.connect(masterGain);
}

function toggleMute() {
  audioMuted = !audioMuted;
  if (masterGain) masterGain.gain.value = audioMuted ? 0 : 0.35;
}

function playTone(freq, dur, type, vol, dest) {
  if (!audioCtx) return;
  const now = audioCtx.currentTime;
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = type || 'square';
  o.frequency.setValueAtTime(freq, now);
  g.gain.setValueAtTime(vol || 0.3, now);
  g.gain.exponentialRampToValueAtTime(0.001, now + dur);
  o.connect(g);
  g.connect(dest || sfxGain);
  o.start(now);
  o.stop(now + dur);
}

function playToneAt(freq, dur, type, vol, startTime, dest) {
  if (!audioCtx) return;
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = type || 'square';
  o.frequency.setValueAtTime(freq, startTime);
  g.gain.setValueAtTime(vol || 0.3, startTime);
  g.gain.exponentialRampToValueAtTime(0.001, startTime + dur);
  o.connect(g);
  g.connect(dest || sfxGain);
  o.start(startTime);
  o.stop(startTime + dur);
}

function playNoise(dur, vol, dest) {
  if (!audioCtx) return;
  const now = audioCtx.currentTime;
  const buf = audioCtx.createBuffer(1, Math.floor(audioCtx.sampleRate * dur), audioCtx.sampleRate);
  const data = buf.getChannelData(0);
  for (let i = 0; i < data.length; i++) data[i] = Math.random() * 2 - 1;
  const src = audioCtx.createBufferSource();
  src.buffer = buf;
  const g = audioCtx.createGain();
  g.gain.setValueAtTime(vol || 0.2, now);
  g.gain.exponentialRampToValueAtTime(0.001, now + dur);
  src.connect(g);
  g.connect(dest || sfxGain);
  src.start(now);
}

// ── SFX ──
function sfxThrust() {
  if (!audioCtx) return;
  playNoise(0.06, 0.08);
  playTone(120 + Math.random() * 30, 0.05, 'sawtooth', 0.06);
}

function sfxRotate() {
  if (!audioCtx) return;
  playNoise(0.03, 0.04);
}

function sfxFire() {
  if (!audioCtx) return;
  playTone(900, 0.06, 'square', 0.15);
  playTone(600, 0.04, 'square', 0.1);
}

function sfxExplosion() {
  if (!audioCtx) return;
  playNoise(0.5, 0.3);
  playTone(60, 0.4, 'sine', 0.25);
  playTone(40, 0.6, 'sine', 0.15);
}

function sfxBombExplode() {
  if (!audioCtx) return;
  playNoise(0.3, 0.2);
  playTone(80, 0.25, 'sine', 0.15);
}

function sfxEnemyHit() {
  if (!audioCtx) return;
  playTone(300, 0.08, 'square', 0.12);
  playTone(200, 0.06, 'triangle', 0.08);
}

function sfxEnemyDie() {
  if (!audioCtx) return;
  playTone(400, 0.1, 'square', 0.15);
  playTone(200, 0.15, 'sawtooth', 0.1);
  playNoise(0.2, 0.12);
}

function sfxLanding() {
  if (!audioCtx) return;
  const now = audioCtx.currentTime;
  // Ascending arpeggio C-E-G-C
  playToneAt(262, 0.15, 'triangle', 0.2, now);
  playToneAt(330, 0.15, 'triangle', 0.2, now + 0.1);
  playToneAt(392, 0.15, 'triangle', 0.2, now + 0.2);
  playToneAt(523, 0.25, 'triangle', 0.25, now + 0.3);
}

function sfxCrash() {
  if (!audioCtx) return;
  playNoise(0.8, 0.35);
  playTone(50, 0.6, 'sine', 0.3);
  playTone(30, 0.8, 'sine', 0.2);
}

function sfxArm() {
  if (!audioCtx) return;
  playTone(800, 0.04, 'square', 0.1);
  playTone(1000, 0.04, 'square', 0.08);
}

function sfxTelegraph() {
  if (!audioCtx) return;
  playTone(600, 0.08, 'sine', 0.1);
  const now = audioCtx.currentTime;
  playToneAt(800, 0.08, 'sine', 0.1, now + 0.12);
}

function sfxBombShot() {
  if (!audioCtx) return;
  playTone(150, 0.12, 'sawtooth', 0.08);
  playTone(100, 0.08, 'square', 0.06);
}

function sfxFirework() {
  if (!audioCtx) return;
  playNoise(0.15, 0.06);
  playTone(800 + Math.random() * 600, 0.12, 'sine', 0.05);
}

function sfxVictory() {
  if (!audioCtx) return;
  const now = audioCtx.currentTime;
  // Ascending fanfare: C-E-G-C-E (triumphant)
  playToneAt(262, 0.2, 'triangle', 0.25, now);
  playToneAt(330, 0.2, 'triangle', 0.25, now + 0.15);
  playToneAt(392, 0.2, 'triangle', 0.25, now + 0.3);
  playToneAt(523, 0.3, 'triangle', 0.3, now + 0.45);
  playToneAt(659, 0.5, 'triangle', 0.3, now + 0.65);
  // Harmonics
  playToneAt(392, 0.4, 'sine', 0.12, now + 0.45);
  playToneAt(523, 0.4, 'sine', 0.12, now + 0.65);
}

// ── Synthwave Music Loop ──
let musicInterval = null;

function startMusic() {
  if (!audioCtx || musicPlaying) return;
  musicPlaying = true;

  // Create a simple repeating synthwave pattern
  const bpm = 110;
  const beatLen = 60 / bpm;
  const barLen = beatLen * 4;

  // Bass notes (A minor progression: Am - F - C - G)
  const bassNotes = [110, 87.3, 130.8, 98];
  // Arp notes
  const arpPatterns = [
    [220, 262, 330, 262], // Am
    [175, 220, 262, 220], // F
    [262, 330, 392, 330], // C
    [196, 247, 294, 247], // G
  ];

  let barIndex = 0;

  function playBar() {
    if (!audioCtx || !musicPlaying) return;
    const now = audioCtx.currentTime;
    const bi = barIndex % 4;

    // Bass drone
    const bassO = audioCtx.createOscillator();
    const bassG = audioCtx.createGain();
    bassO.type = 'sawtooth';
    bassO.frequency.setValueAtTime(bassNotes[bi], now);
    bassG.gain.setValueAtTime(0.06, now);
    bassG.gain.setValueAtTime(0.06, now + barLen * 0.8);
    bassG.gain.exponentialRampToValueAtTime(0.001, now + barLen * 0.95);
    // Low-pass filter for bass warmth
    const bassFilter = audioCtx.createBiquadFilter();
    bassFilter.type = 'lowpass';
    bassFilter.frequency.value = 200;
    bassO.connect(bassFilter);
    bassFilter.connect(bassG);
    bassG.connect(musicGain);
    bassO.start(now);
    bassO.stop(now + barLen);

    // Arp sequence (16th notes across the bar)
    const arp = arpPatterns[bi];
    for (let i = 0; i < 8; i++) {
      const noteTime = now + i * (barLen / 8);
      const noteFreq = arp[i % 4] * (i >= 4 ? 2 : 1);
      const arpO = audioCtx.createOscillator();
      const arpG = audioCtx.createGain();
      arpO.type = 'square';
      arpO.frequency.setValueAtTime(noteFreq, noteTime);
      arpG.gain.setValueAtTime(0.04, noteTime);
      arpG.gain.exponentialRampToValueAtTime(0.001, noteTime + beatLen * 0.4);
      // Filter for that 80s sound
      const arpFilter = audioCtx.createBiquadFilter();
      arpFilter.type = 'lowpass';
      arpFilter.frequency.value = 1500 + Math.sin(barIndex * 0.5 + i * 0.3) * 500;
      arpO.connect(arpFilter);
      arpFilter.connect(arpG);
      arpG.connect(musicGain);
      arpO.start(noteTime);
      arpO.stop(noteTime + beatLen * 0.45);
    }

    // Hi-hat pattern (8th notes)
    for (let i = 0; i < 8; i++) {
      const hatTime = now + i * (barLen / 8);
      const accent = i % 2 === 0 ? 0.03 : 0.015;
      const hatBuf = audioCtx.createBuffer(1, Math.floor(audioCtx.sampleRate * 0.04), audioCtx.sampleRate);
      const hatData = hatBuf.getChannelData(0);
      for (let j = 0; j < hatData.length; j++) hatData[j] = Math.random() * 2 - 1;
      const hatSrc = audioCtx.createBufferSource();
      hatSrc.buffer = hatBuf;
      const hatG = audioCtx.createGain();
      hatG.gain.setValueAtTime(accent, hatTime);
      hatG.gain.exponentialRampToValueAtTime(0.001, hatTime + 0.04);
      const hatFilter = audioCtx.createBiquadFilter();
      hatFilter.type = 'highpass';
      hatFilter.frequency.value = 8000;
      hatSrc.connect(hatFilter);
      hatFilter.connect(hatG);
      hatG.connect(musicGain);
      hatSrc.start(hatTime);
    }

    barIndex++;
  }

  // Play first bar immediately, then schedule repeating
  playBar();
  musicInterval = setInterval(playBar, barLen * 1000);
}

function stopMusic() {
  musicPlaying = false;
  if (musicInterval) {
    clearInterval(musicInterval);
    musicInterval = null;
  }
}

// Thrust sound throttle
let lastThrustSfx = 0;
let lastRotSfx = 0;

// ── Main Game Loop ──
const FIXED_DT = 1 / 60;
let accumulator = 0;
let lastTime = 0;

function gameLoop(timestamp) {
  let dt = (timestamp - lastTime) / 1000;
  if (lastTime === 0) dt = FIXED_DT;
  lastTime = timestamp;
  dt = Math.min(dt, 0.1); // prevent spiral of death

  accumulator += dt;
  while (accumulator >= FIXED_DT) {
    update(FIXED_DT);
    accumulator -= FIXED_DT;
  }

  draw();
  requestAnimationFrame(gameLoop);
}

function update(dt) {
  stateTimer += dt;
  updateShake(dt);
  updateCamera();

  if (state === STATE.PLAYING) {
    updatePlaying(dt);
  }
  if (state === STATE.CRASHED || state === STATE.LANDED) {
    updateParticles(dt);
  }
  if (state === STATE.LANDED) {
    updateAstronaut(dt);
  }
  if (state === STATE.WIN) {
    updateWinFireworks(dt);
  }
  if (state === STATE.CRASHED && lives <= 0) {
    // Spawn embers for game over screen
    if (Math.random() < 0.3) spawnEmber();
    updateEmbers(dt);
  }
}

function draw() {
  // Clear
  ctx.fillStyle = '#08080f';
  ctx.fillRect(0, 0, W, H);

  if (state !== STATE.TITLE && state !== STATE.WIN) {
    // Parallax star layer (slower scroll for depth)
    ctx.save();
    ctx.translate(shakeX - cameraX * 0.3, shakeY);
    drawStars();
    ctx.restore();

    // World layer (full camera offset)
    ctx.save();
    ctx.translate(shakeX - cameraX, shakeY);
    drawTerrain();
    drawEnemies();
    drawBombs();
    drawBullets();
    drawParticles();
    drawShip();
    if (state === STATE.LANDED) drawAstronaut();
    ctx.restore();
    drawHUD();
  }

  drawOverlay();
}

// ── Start ──
requestAnimationFrame(gameLoop);

</script>
</body>
</html>
